/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type AWSClustersDNSApi interface {

	/*
	ReturnOneCustomDnsConfigurationForAtlasClustersOnAws Return One Custom DNS Configuration for Atlas Clusters on AWS

	Returns the custom DNS configuration for AWS clusters in the specified project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@return AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest
	*/
	ReturnOneCustomDnsConfigurationForAtlasClustersOnAws(ctx context.Context, groupId string) AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest

	// ReturnOneCustomDnsConfigurationForAtlasClustersOnAwsExecute executes the request
	//  @return AWSCustomDNSEnabledView
	ReturnOneCustomDnsConfigurationForAtlasClustersOnAwsExecute(r AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) (*AWSCustomDNSEnabledView, *http.Response, error)

	/*
	ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAws Toggle State of One Custom DNS Configuration for Atlas Clusters on AWS

	Enables or disables the custom DNS configuration for AWS clusters in the specified project. Enable custom DNS if you use AWS VPC peering and use your own DNS servers. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@return AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest
	*/
	ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAws(ctx context.Context, groupId string) AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest

	// ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsExecute executes the request
	//  @return AWSCustomDNSEnabledView
	ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsExecute(r AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) (*AWSCustomDNSEnabledView, *http.Response, error)
}

// AWSClustersDNSApiService AWSClustersDNSApi service
type AWSClustersDNSApiService service

type AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest struct {
	ctx context.Context
	ApiService AWSClustersDNSApi
	groupId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) Envelope(envelope bool) AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) Pretty(pretty bool) AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	r.pretty = &pretty
	return r
}

func (r AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) Execute() (*AWSCustomDNSEnabledView, *http.Response, error) {
	return r.ApiService.ReturnOneCustomDnsConfigurationForAtlasClustersOnAwsExecute(r)
}

/*
ReturnOneCustomDnsConfigurationForAtlasClustersOnAws Return One Custom DNS Configuration for Atlas Clusters on AWS

Returns the custom DNS configuration for AWS clusters in the specified project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @return AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest
*/
func (a *AWSClustersDNSApiService) ReturnOneCustomDnsConfigurationForAtlasClustersOnAws(ctx context.Context, groupId string) AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	return AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AWSCustomDNSEnabledView
func (a *AWSClustersDNSApiService) ReturnOneCustomDnsConfigurationForAtlasClustersOnAwsExecute(r AWSClustersDNSApiReturnOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) (*AWSCustomDNSEnabledView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AWSCustomDNSEnabledView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AWSClustersDNSApiService.ReturnOneCustomDnsConfigurationForAtlasClustersOnAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/awsCustomDNS"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest struct {
	ctx context.Context
	ApiService AWSClustersDNSApi
	groupId string
	aWSCustomDNSEnabledView *AWSCustomDNSEnabledView
	envelope *bool
	pretty *bool
}

// Enables or disables the custom DNS configuration for AWS clusters in the specified project.
func (r AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) AWSCustomDNSEnabledView(aWSCustomDNSEnabledView AWSCustomDNSEnabledView) AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	r.aWSCustomDNSEnabledView = &aWSCustomDNSEnabledView
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) Envelope(envelope bool) AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) Pretty(pretty bool) AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	r.pretty = &pretty
	return r
}

func (r AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) Execute() (*AWSCustomDNSEnabledView, *http.Response, error) {
	return r.ApiService.ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsExecute(r)
}

/*
ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAws Toggle State of One Custom DNS Configuration for Atlas Clusters on AWS

Enables or disables the custom DNS configuration for AWS clusters in the specified project. Enable custom DNS if you use AWS VPC peering and use your own DNS servers. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @return AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest
*/
func (a *AWSClustersDNSApiService) ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAws(ctx context.Context, groupId string) AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest {
	return AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AWSCustomDNSEnabledView
func (a *AWSClustersDNSApiService) ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsExecute(r AWSClustersDNSApiToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAwsRequest) (*AWSCustomDNSEnabledView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AWSCustomDNSEnabledView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AWSClustersDNSApiService.ToggleOneStateOfOneCustomDnsConfigurationForAtlasClustersOnAws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/awsCustomDNS"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if r.aWSCustomDNSEnabledView == nil {
		return localVarReturnValue, nil, reportError("aWSCustomDNSEnabledView is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aWSCustomDNSEnabledView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
