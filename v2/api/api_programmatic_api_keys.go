/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type ProgrammaticAPIKeysApi interface {

	/*
	AssignOneOrganizationApiKeyToOneProject Assign One Organization API Key to One Project

	Assigns the specified organization API key to the specified project. Users with the Project Owner role in the project associated with the API key can then use the organization API key to access the resources. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that you want to assign to one project.
	@return ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest
	*/
	AssignOneOrganizationApiKeyToOneProject(ctx context.Context, groupId string, apiUserId string) ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest

	// AssignOneOrganizationApiKeyToOneProjectExecute executes the request
	//  @return ApiApiUserView
	AssignOneOrganizationApiKeyToOneProjectExecute(r ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest) (*ApiApiUserView, *http.Response, error)

	/*
	CreateAccessListEntriesForOneOrganizationApiKey Create Access List Entries for One Organization API Key

	Creates the access list entries for the specified organization API key. Resources require all API requests originate from IP addresses on the API access list. To use this resource, the requesting API Key must have the Read Write role and an entry for the project access list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for which you want to create a new access list entry.
	@return ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest
	*/
	CreateAccessListEntriesForOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest

	// CreateAccessListEntriesForOneOrganizationApiKeyExecute executes the request
	//  @return ApiUserAccessListView
	CreateAccessListEntriesForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) (*ApiUserAccessListView, *http.Response, error)

	/*
	CreateAndAssignOneOrganizationApiKeyToOneProject Create and Assign One Organization API Key to One Project

	Creates and assigns the specified organization API key to the specified project. Users with the Project Owner role in the project associated with the API key can use the organization API key to access the resources. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@return ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest
	*/
	CreateAndAssignOneOrganizationApiKeyToOneProject(ctx context.Context, groupId string) ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest

	// CreateAndAssignOneOrganizationApiKeyToOneProjectExecute executes the request
	//  @return ApiApiUserView
	CreateAndAssignOneOrganizationApiKeyToOneProjectExecute(r ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest) (*ApiApiUserView, *http.Response, error)

	/*
	CreateOneOrganizationApiKey Create One Organization API Key

	Creates one API key for the specified organization. An organization API key grants programmatic access to an organization. You can't use the API key to log into the console. To use this resource, the requesting API Key must have the Organization User Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@return ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest
	*/
	CreateOneOrganizationApiKey(ctx context.Context, orgId string) ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest

	// CreateOneOrganizationApiKeyExecute executes the request
	//  @return ApiApiUserView
	CreateOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest) (*ApiApiUserView, *http.Response, error)

	/*
	RemoveOneAccessListEntryForOneOrganizationApiKey Remove One Access List Entry for One Organization API Key

	Removes the specified access list entry from the specified organization API key. Resources require all API requests originate from the IP addresses on the API access list. To use this resource, the requesting API Key must have the Read Write role and an entry for the project access list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for which you want to remove access list entries.
	@param ipAddress One IP address or multiple IP addresses represented as one CIDR block to limit requests to API resources in the specified organization. When adding a CIDR block with a subnet mask, such as 192.0.2.0/24, use the URL-encoded value %2F for the forward slash /.
	@return ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest
	*/
	RemoveOneAccessListEntryForOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string, ipAddress string) ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest

	// RemoveOneAccessListEntryForOneOrganizationApiKeyExecute executes the request
	RemoveOneAccessListEntryForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest) (*http.Response, error)

	/*
	RemoveOneOrganizationApiKey Remove One Organization API Key

	Removes one organization API key from the specified organization. When you remove an API key from an organization, MongoDB Cloud also removes that key from any projects that use that key. To use this resource, the requesting API Key must have the Organization User Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key.
	@return ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest
	*/
	RemoveOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest

	// RemoveOneOrganizationApiKeyExecute executes the request
	RemoveOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest) (*http.Response, error)

	/*
	ReturnAllAccessListEntriesForOneOrganizationApiKey Return All Access List Entries for One Organization API Key

	Returns all access list entries that you configured for the specified organization API key. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for which you want to return access list entries.
	@return ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest
	*/
	ReturnAllAccessListEntriesForOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest

	// ReturnAllAccessListEntriesForOneOrganizationApiKeyExecute executes the request
	//  @return PaginatedApiUserAccessListView
	ReturnAllAccessListEntriesForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) (*PaginatedApiUserAccessListView, *http.Response, error)

	/*
	ReturnAllOrganizationApiKeys Return All Organization API Keys

	Returns all organization API keys for the specified organization. The organization API keys grant programmatic access to an organization. You can't use the API key to log into MongoDB Cloud through the console. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@return ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest
	*/
	ReturnAllOrganizationApiKeys(ctx context.Context, orgId string) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest

	// ReturnAllOrganizationApiKeysExecute executes the request
	//  @return PaginatedApiApiUserView
	ReturnAllOrganizationApiKeysExecute(r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) (*PaginatedApiApiUserView, *http.Response, error)

	/*
	ReturnAllOrganizationApiKeysAssignedToOneProject Return All Organization API Keys Assigned to One Project

	Returns all organization API keys that you assigned to the specified project. Users with the Project Owner role in the project associated with the API key can use the organization API key to access the resources. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@return ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest
	*/
	ReturnAllOrganizationApiKeysAssignedToOneProject(ctx context.Context, groupId string) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest

	// ReturnAllOrganizationApiKeysAssignedToOneProjectExecute executes the request
	//  @return PaginatedApiApiUserView
	ReturnAllOrganizationApiKeysAssignedToOneProjectExecute(r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) (*PaginatedApiApiUserView, *http.Response, error)

	/*
	ReturnOneAccessListEntryForOneOrganizationApiKey Return One Access List Entry for One Organization API Key

	Returns one access list entry for the specified organization API key. Resources require  all API requests originate from IP addresses on the API access list. To use this resource,  the requesting API Key must have the Organization Member role. This resource  doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param ipAddress One IP address or multiple IP addresses represented as one CIDR block to limit  requests to API resources in the specified organization. When adding a CIDR block with a subnet mask, such as  192.0.2.0/24, use the URL-encoded value %2F for the forward slash /.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for  which you want to return access list entries.
	@return ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest
	*/
	ReturnOneAccessListEntryForOneOrganizationApiKey(ctx context.Context, orgId string, ipAddress string, apiUserId string) ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest

	// ReturnOneAccessListEntryForOneOrganizationApiKeyExecute executes the request
	//  @return ApiUserAccessListView
	ReturnOneAccessListEntryForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest) (*ApiUserAccessListView, *http.Response, error)

	/*
	ReturnOneOrganizationApiKey Return One Organization API Key

	Returns one organization API key. The organization API keys grant programmatic access to an organization. You can't use the API key to log into MongoDB Cloud through the user interface. To use this resource, the requesting API Key must have the  Organization Member role. This resource doesn't require the API Key to have an  Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that  you want to update.
	@return ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest
	*/
	ReturnOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest

	// ReturnOneOrganizationApiKeyExecute executes the request
	//  @return ApiApiUserView
	ReturnOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest) (*ApiApiUserView, *http.Response, error)

	/*
	UnassignOneOrganizationApiKeyFromOneProject Unassign One Organization API Key from One Project

	Removes one organization API key from the specified project. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that you want to unassign from one project.
	@return ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest
	*/
	UnassignOneOrganizationApiKeyFromOneProject(ctx context.Context, groupId string, apiUserId string) ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest

	// UnassignOneOrganizationApiKeyFromOneProjectExecute executes the request
	UnassignOneOrganizationApiKeyFromOneProjectExecute(r ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest) (*http.Response, error)

	/*
	UpdateOneOrganizationApiKey Update One Organization API Key

	Updates one organization API key in the specified organization. The organization API keys  grant programmatic access to an organization. To use this resource, the requesting  API Key must have the Organization User Admin role. This resource doesn't require  the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key you  want to update.
	@return ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest
	*/
	UpdateOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest

	// UpdateOneOrganizationApiKeyExecute executes the request
	//  @return ApiApiUserView
	UpdateOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest) (*ApiApiUserView, *http.Response, error)

	/*
	UpdateRoles Update Roles of One Organization API Key to One Project

	Updates the roles of the organization API key that you specify for the project that you specify. You must specify at least one valid role for the project. The application removes any roles that you do not include in this request if they were previously set in the organization API key that you specify for the project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that you want to unassign from one project.
	@return ProgrammaticAPIKeysApiUpdateRolesRequest
	*/
	UpdateRoles(ctx context.Context, groupId string, apiUserId string) ProgrammaticAPIKeysApiUpdateRolesRequest

	// UpdateRolesExecute executes the request
	//  @return ApiApiUserView
	UpdateRolesExecute(r ProgrammaticAPIKeysApiUpdateRolesRequest) (*ApiApiUserView, *http.Response, error)
}

// ProgrammaticAPIKeysApiService ProgrammaticAPIKeysApi service
type ProgrammaticAPIKeysApiService service

type ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	groupId string
	apiUserId string
	apiUserRoleAssignment *[]ApiUserRoleAssignment
	envelope *bool
	pretty *bool
}

// Organization API key to be assigned to the specified project.
func (r ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest) ApiUserRoleAssignment(apiUserRoleAssignment []ApiUserRoleAssignment) ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest {
	r.apiUserRoleAssignment = &apiUserRoleAssignment
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest) Execute() (*ApiApiUserView, *http.Response, error) {
	return r.ApiService.AssignOneOrganizationApiKeyToOneProjectExecute(r)
}

/*
AssignOneOrganizationApiKeyToOneProject Assign One Organization API Key to One Project

Assigns the specified organization API key to the specified project. Users with the Project Owner role in the project associated with the API key can then use the organization API key to access the resources. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that you want to assign to one project.
 @return ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest
*/
func (a *ProgrammaticAPIKeysApiService) AssignOneOrganizationApiKeyToOneProject(ctx context.Context, groupId string, apiUserId string) ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest {
	return ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return ApiApiUserView
func (a *ProgrammaticAPIKeysApiService) AssignOneOrganizationApiKeyToOneProjectExecute(r ProgrammaticAPIKeysApiAssignOneOrganizationApiKeyToOneProjectRequest) (*ApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.AssignOneOrganizationApiKeyToOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/apiKeys/{apiUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}
	if r.apiUserRoleAssignment == nil {
		return localVarReturnValue, nil, reportError("apiUserRoleAssignment is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiUserRoleAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiUserId string
	apiUserAccessListView *[]ApiUserAccessListView
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Access list entries to be created for the specified organization API key.
func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) ApiUserAccessListView(apiUserAccessListView []ApiUserAccessListView) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	r.apiUserAccessListView = &apiUserAccessListView
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) IncludeCount(includeCount bool) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) ItemsPerPage(itemsPerPage int32) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) PageNum(pageNum int32) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) Execute() (*ApiUserAccessListView, *http.Response, error) {
	return r.ApiService.CreateAccessListEntriesForOneOrganizationApiKeyExecute(r)
}

/*
CreateAccessListEntriesForOneOrganizationApiKey Create Access List Entries for One Organization API Key

Creates the access list entries for the specified organization API key. Resources require all API requests originate from IP addresses on the API access list. To use this resource, the requesting API Key must have the Read Write role and an entry for the project access list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for which you want to create a new access list entry.
 @return ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) CreateAccessListEntriesForOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return ApiUserAccessListView
func (a *ProgrammaticAPIKeysApiService) CreateAccessListEntriesForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiCreateAccessListEntriesForOneOrganizationApiKeyRequest) (*ApiUserAccessListView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiUserAccessListView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.CreateAccessListEntriesForOneOrganizationApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}/accessList"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}
	if r.apiUserAccessListView == nil {
		return localVarReturnValue, nil, reportError("apiUserAccessListView is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiUserAccessListView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	groupId string
	apiCreateApiKeyView *ApiCreateApiKeyView
	envelope *bool
	pretty *bool
}

// Organization API key to be created and assigned to the specified project. This request requires a minimum of one of the two body parameters.
func (r ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest) ApiCreateApiKeyView(apiCreateApiKeyView ApiCreateApiKeyView) ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest {
	r.apiCreateApiKeyView = &apiCreateApiKeyView
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest) Execute() (*ApiApiUserView, *http.Response, error) {
	return r.ApiService.CreateAndAssignOneOrganizationApiKeyToOneProjectExecute(r)
}

/*
CreateAndAssignOneOrganizationApiKeyToOneProject Create and Assign One Organization API Key to One Project

Creates and assigns the specified organization API key to the specified project. Users with the Project Owner role in the project associated with the API key can use the organization API key to access the resources. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @return ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest
*/
func (a *ProgrammaticAPIKeysApiService) CreateAndAssignOneOrganizationApiKeyToOneProject(ctx context.Context, groupId string) ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest {
	return ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ApiApiUserView
func (a *ProgrammaticAPIKeysApiService) CreateAndAssignOneOrganizationApiKeyToOneProjectExecute(r ProgrammaticAPIKeysApiCreateAndAssignOneOrganizationApiKeyToOneProjectRequest) (*ApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.CreateAndAssignOneOrganizationApiKeyToOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/apiKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if r.apiCreateApiKeyView == nil {
		return localVarReturnValue, nil, reportError("apiCreateApiKeyView is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiCreateApiKeyView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiCreateApiKeyView *ApiCreateApiKeyView
	envelope *bool
	pretty *bool
}

// Organization API Key to be created. This request requires a minimum of one of the two body parameters.
func (r ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest) ApiCreateApiKeyView(apiCreateApiKeyView ApiCreateApiKeyView) ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest {
	r.apiCreateApiKeyView = &apiCreateApiKeyView
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest) Execute() (*ApiApiUserView, *http.Response, error) {
	return r.ApiService.CreateOneOrganizationApiKeyExecute(r)
}

/*
CreateOneOrganizationApiKey Create One Organization API Key

Creates one API key for the specified organization. An organization API key grants programmatic access to an organization. You can't use the API key to log into the console. To use this resource, the requesting API Key must have the Organization User Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @return ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) CreateOneOrganizationApiKey(ctx context.Context, orgId string) ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ApiApiUserView
func (a *ProgrammaticAPIKeysApiService) CreateOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiCreateOneOrganizationApiKeyRequest) (*ApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.CreateOneOrganizationApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if r.apiCreateApiKeyView == nil {
		return localVarReturnValue, nil, reportError("apiCreateApiKeyView is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiCreateApiKeyView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiUserId string
	ipAddress string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOneAccessListEntryForOneOrganizationApiKeyExecute(r)
}

/*
RemoveOneAccessListEntryForOneOrganizationApiKey Remove One Access List Entry for One Organization API Key

Removes the specified access list entry from the specified organization API key. Resources require all API requests originate from the IP addresses on the API access list. To use this resource, the requesting API Key must have the Read Write role and an entry for the project access list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for which you want to remove access list entries.
 @param ipAddress One IP address or multiple IP addresses represented as one CIDR block to limit requests to API resources in the specified organization. When adding a CIDR block with a subnet mask, such as 192.0.2.0/24, use the URL-encoded value %2F for the forward slash /.
 @return ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) RemoveOneAccessListEntryForOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string, ipAddress string) ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		apiUserId: apiUserId,
		ipAddress: ipAddress,
	}
}

// Execute executes the request
func (a *ProgrammaticAPIKeysApiService) RemoveOneAccessListEntryForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiRemoveOneAccessListEntryForOneOrganizationApiKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.RemoveOneAccessListEntryForOneOrganizationApiKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}/accessList/{ipAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipAddress"+"}", url.PathEscape(parameterToString(r.ipAddress, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return nil, reportError("apiUserId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiUserId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOneOrganizationApiKeyExecute(r)
}

/*
RemoveOneOrganizationApiKey Remove One Organization API Key

Removes one organization API key from the specified organization. When you remove an API key from an organization, MongoDB Cloud also removes that key from any projects that use that key. To use this resource, the requesting API Key must have the Organization User Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key.
 @return ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) RemoveOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
func (a *ProgrammaticAPIKeysApiService) RemoveOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiRemoveOneOrganizationApiKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.RemoveOneOrganizationApiKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return nil, reportError("apiUserId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiUserId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) IncludeCount(includeCount bool) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) ItemsPerPage(itemsPerPage int32) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) PageNum(pageNum int32) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) Execute() (*PaginatedApiUserAccessListView, *http.Response, error) {
	return r.ApiService.ReturnAllAccessListEntriesForOneOrganizationApiKeyExecute(r)
}

/*
ReturnAllAccessListEntriesForOneOrganizationApiKey Return All Access List Entries for One Organization API Key

Returns all access list entries that you configured for the specified organization API key. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for which you want to return access list entries.
 @return ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) ReturnAllAccessListEntriesForOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return PaginatedApiUserAccessListView
func (a *ProgrammaticAPIKeysApiService) ReturnAllAccessListEntriesForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiReturnAllAccessListEntriesForOneOrganizationApiKeyRequest) (*PaginatedApiUserAccessListView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApiUserAccessListView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.ReturnAllAccessListEntriesForOneOrganizationApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}/accessList"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) IncludeCount(includeCount bool) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) ItemsPerPage(itemsPerPage int32) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) PageNum(pageNum int32) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) Execute() (*PaginatedApiApiUserView, *http.Response, error) {
	return r.ApiService.ReturnAllOrganizationApiKeysExecute(r)
}

/*
ReturnAllOrganizationApiKeys Return All Organization API Keys

Returns all organization API keys for the specified organization. The organization API keys grant programmatic access to an organization. You can't use the API key to log into MongoDB Cloud through the console. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @return ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest
*/
func (a *ProgrammaticAPIKeysApiService) ReturnAllOrganizationApiKeys(ctx context.Context, orgId string) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest {
	return ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return PaginatedApiApiUserView
func (a *ProgrammaticAPIKeysApiService) ReturnAllOrganizationApiKeysExecute(r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysRequest) (*PaginatedApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.ReturnAllOrganizationApiKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	groupId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) IncludeCount(includeCount bool) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) ItemsPerPage(itemsPerPage int32) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) PageNum(pageNum int32) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) Execute() (*PaginatedApiApiUserView, *http.Response, error) {
	return r.ApiService.ReturnAllOrganizationApiKeysAssignedToOneProjectExecute(r)
}

/*
ReturnAllOrganizationApiKeysAssignedToOneProject Return All Organization API Keys Assigned to One Project

Returns all organization API keys that you assigned to the specified project. Users with the Project Owner role in the project associated with the API key can use the organization API key to access the resources. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @return ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest
*/
func (a *ProgrammaticAPIKeysApiService) ReturnAllOrganizationApiKeysAssignedToOneProject(ctx context.Context, groupId string) ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest {
	return ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return PaginatedApiApiUserView
func (a *ProgrammaticAPIKeysApiService) ReturnAllOrganizationApiKeysAssignedToOneProjectExecute(r ProgrammaticAPIKeysApiReturnAllOrganizationApiKeysAssignedToOneProjectRequest) (*PaginatedApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.ReturnAllOrganizationApiKeysAssignedToOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/apiKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	ipAddress string
	apiUserId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest) Execute() (*ApiUserAccessListView, *http.Response, error) {
	return r.ApiService.ReturnOneAccessListEntryForOneOrganizationApiKeyExecute(r)
}

/*
ReturnOneAccessListEntryForOneOrganizationApiKey Return One Access List Entry for One Organization API Key

Returns one access list entry for the specified organization API key. Resources require  all API requests originate from IP addresses on the API access list. To use this resource,  the requesting API Key must have the Organization Member role. This resource  doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param ipAddress One IP address or multiple IP addresses represented as one CIDR block to limit  requests to API resources in the specified organization. When adding a CIDR block with a subnet mask, such as  192.0.2.0/24, use the URL-encoded value %2F for the forward slash /.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key for  which you want to return access list entries.
 @return ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) ReturnOneAccessListEntryForOneOrganizationApiKey(ctx context.Context, orgId string, ipAddress string, apiUserId string) ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		ipAddress: ipAddress,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return ApiUserAccessListView
func (a *ProgrammaticAPIKeysApiService) ReturnOneAccessListEntryForOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiReturnOneAccessListEntryForOneOrganizationApiKeyRequest) (*ApiUserAccessListView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiUserAccessListView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.ReturnOneAccessListEntryForOneOrganizationApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}/accessList/{ipAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipAddress"+"}", url.PathEscape(parameterToString(r.ipAddress, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiUserId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest) Execute() (*ApiApiUserView, *http.Response, error) {
	return r.ApiService.ReturnOneOrganizationApiKeyExecute(r)
}

/*
ReturnOneOrganizationApiKey Return One Organization API Key

Returns one organization API key. The organization API keys grant programmatic access to an organization. You can't use the API key to log into MongoDB Cloud through the user interface. To use this resource, the requesting API Key must have the  Organization Member role. This resource doesn't require the API Key to have an  Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that  you want to update.
 @return ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) ReturnOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return ApiApiUserView
func (a *ProgrammaticAPIKeysApiService) ReturnOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiReturnOneOrganizationApiKeyRequest) (*ApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.ReturnOneOrganizationApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	groupId string
	apiUserId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnassignOneOrganizationApiKeyFromOneProjectExecute(r)
}

/*
UnassignOneOrganizationApiKeyFromOneProject Unassign One Organization API Key from One Project

Removes one organization API key from the specified project. To use this resource, the requesting API Key must have the Project User Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that you want to unassign from one project.
 @return ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest
*/
func (a *ProgrammaticAPIKeysApiService) UnassignOneOrganizationApiKeyFromOneProject(ctx context.Context, groupId string, apiUserId string) ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest {
	return ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
func (a *ProgrammaticAPIKeysApiService) UnassignOneOrganizationApiKeyFromOneProjectExecute(r ProgrammaticAPIKeysApiUnassignOneOrganizationApiKeyFromOneProjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.UnassignOneOrganizationApiKeyFromOneProject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/apiKeys/{apiUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return nil, reportError("apiUserId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	orgId string
	apiUserId string
	apiApiUserView *ApiApiUserView
	envelope *bool
	pretty *bool
}

// Organization API key to be updated. This request requires a minimum of one of the two body parameters.
func (r ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest) ApiApiUserView(apiApiUserView ApiApiUserView) ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest {
	r.apiApiUserView = &apiApiUserView
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest) Envelope(envelope bool) ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest) Execute() (*ApiApiUserView, *http.Response, error) {
	return r.ApiService.UpdateOneOrganizationApiKeyExecute(r)
}

/*
UpdateOneOrganizationApiKey Update One Organization API Key

Updates one organization API key in the specified organization. The organization API keys  grant programmatic access to an organization. To use this resource, the requesting  API Key must have the Organization User Admin role. This resource doesn't require  the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key you  want to update.
 @return ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest
*/
func (a *ProgrammaticAPIKeysApiService) UpdateOneOrganizationApiKey(ctx context.Context, orgId string, apiUserId string) ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest {
	return ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return ApiApiUserView
func (a *ProgrammaticAPIKeysApiService) UpdateOneOrganizationApiKeyExecute(r ProgrammaticAPIKeysApiUpdateOneOrganizationApiKeyRequest) (*ApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.UpdateOneOrganizationApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/apiKeys/{apiUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}
	if r.apiApiUserView == nil {
		return localVarReturnValue, nil, reportError("apiApiUserView is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiApiUserView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgrammaticAPIKeysApiUpdateRolesRequest struct {
	ctx context.Context
	ApiService ProgrammaticAPIKeysApi
	groupId string
	apiUserId string
	apiCreateApiKeyView *ApiCreateApiKeyView
	pageNum *int32
	itemsPerPage *int32
	includeCount *bool
	pretty *bool
}

// Organization API Key to be updated. This request requires a minimum of one of the two body parameters.
func (r ProgrammaticAPIKeysApiUpdateRolesRequest) ApiCreateApiKeyView(apiCreateApiKeyView ApiCreateApiKeyView) ProgrammaticAPIKeysApiUpdateRolesRequest {
	r.apiCreateApiKeyView = &apiCreateApiKeyView
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ProgrammaticAPIKeysApiUpdateRolesRequest) PageNum(pageNum int32) ProgrammaticAPIKeysApiUpdateRolesRequest {
	r.pageNum = &pageNum
	return r
}

// Number of items that the response returns per page.
func (r ProgrammaticAPIKeysApiUpdateRolesRequest) ItemsPerPage(itemsPerPage int32) ProgrammaticAPIKeysApiUpdateRolesRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ProgrammaticAPIKeysApiUpdateRolesRequest) IncludeCount(includeCount bool) ProgrammaticAPIKeysApiUpdateRolesRequest {
	r.includeCount = &includeCount
	return r
}

// Flag that indicates whether the response body should be in the &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/Prettyprint\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;prettyprint&lt;/a&gt; format.
func (r ProgrammaticAPIKeysApiUpdateRolesRequest) Pretty(pretty bool) ProgrammaticAPIKeysApiUpdateRolesRequest {
	r.pretty = &pretty
	return r
}

func (r ProgrammaticAPIKeysApiUpdateRolesRequest) Execute() (*ApiApiUserView, *http.Response, error) {
	return r.ApiService.UpdateRolesExecute(r)
}

/*
UpdateRoles Update Roles of One Organization API Key to One Project

Updates the roles of the organization API key that you specify for the project that you specify. You must specify at least one valid role for the project. The application removes any roles that you do not include in this request if they were previously set in the organization API key that you specify for the project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @param apiUserId Unique 24-hexadecimal digit string that identifies this organization API key that you want to unassign from one project.
 @return ProgrammaticAPIKeysApiUpdateRolesRequest
*/
func (a *ProgrammaticAPIKeysApiService) UpdateRoles(ctx context.Context, groupId string, apiUserId string) ProgrammaticAPIKeysApiUpdateRolesRequest {
	return ProgrammaticAPIKeysApiUpdateRolesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		apiUserId: apiUserId,
	}
}

// Execute executes the request
//  @return ApiApiUserView
func (a *ProgrammaticAPIKeysApiService) UpdateRolesExecute(r ProgrammaticAPIKeysApiUpdateRolesRequest) (*ApiApiUserView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApiUserView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgrammaticAPIKeysApiService.UpdateRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/apiKeys/{apiUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiUserId"+"}", url.PathEscape(parameterToString(r.apiUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.apiUserId) < 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have at least 24 elements")
	}
	if strlen(r.apiUserId) > 24 {
		return localVarReturnValue, nil, reportError("apiUserId must have less than 24 elements")
	}
	if r.apiCreateApiKeyView == nil {
		return localVarReturnValue, nil, reportError("apiCreateApiKeyView is required and must be specified")
	}

	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/vnd.atlas.unversioned+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiCreateApiKeyView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
