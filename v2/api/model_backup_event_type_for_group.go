/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// BackupEventTypeForGroup Unique identifier of event type.
type BackupEventTypeForGroup string

// List of BackupEventTypeForGroup
const (
	BACKUPEVENTTYPEFORGROUP_OPLOG_CURRENT BackupEventTypeForGroup = "OPLOG_CURRENT"
	BACKUPEVENTTYPEFORGROUP_OPLOG_BEHIND BackupEventTypeForGroup = "OPLOG_BEHIND"
	BACKUPEVENTTYPEFORGROUP_RESYNC_PERFORMED BackupEventTypeForGroup = "RESYNC_PERFORMED"
	BACKUPEVENTTYPEFORGROUP_RESYNC_REQUIRED BackupEventTypeForGroup = "RESYNC_REQUIRED"
	BACKUPEVENTTYPEFORGROUP_CONSISTENT_BACKUP_CONFIGURATION BackupEventTypeForGroup = "CONSISTENT_BACKUP_CONFIGURATION"
	BACKUPEVENTTYPEFORGROUP_INCONSISTENT_BACKUP_CONFIGURATION BackupEventTypeForGroup = "INCONSISTENT_BACKUP_CONFIGURATION"
	BACKUPEVENTTYPEFORGROUP_GOOD_CLUSTERSHOT BackupEventTypeForGroup = "GOOD_CLUSTERSHOT"
	BACKUPEVENTTYPEFORGROUP_BAD_CLUSTERSHOTS BackupEventTypeForGroup = "BAD_CLUSTERSHOTS"
	BACKUPEVENTTYPEFORGROUP_INITIAL_SYNC_STARTED_AUDIT BackupEventTypeForGroup = "INITIAL_SYNC_STARTED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_INITIAL_SYNC_FINISHED_AUDIT BackupEventTypeForGroup = "INITIAL_SYNC_FINISHED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RS_STATE_CHANGED_AUDIT BackupEventTypeForGroup = "RS_STATE_CHANGED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTER_STATE_CHANGED_AUDIT BackupEventTypeForGroup = "CLUSTER_STATE_CHANGED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RESTORE_REQUESTED_AUDIT BackupEventTypeForGroup = "RESTORE_REQUESTED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_SYNC_REQUIRED_AUDIT BackupEventTypeForGroup = "SYNC_REQUIRED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_SYNC_PENDING_AUDIT BackupEventTypeForGroup = "SYNC_PENDING_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTERSHOT_DELETED_AUDIT BackupEventTypeForGroup = "CLUSTERSHOT_DELETED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_SNAPSHOT_DELETED_AUDIT BackupEventTypeForGroup = "SNAPSHOT_DELETED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RS_CREDENTIAL_UPDATED_AUDIT BackupEventTypeForGroup = "RS_CREDENTIAL_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTER_CREDENTIAL_UPDATED_AUDIT BackupEventTypeForGroup = "CLUSTER_CREDENTIAL_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RS_BLACKLIST_UPDATED_AUDIT BackupEventTypeForGroup = "RS_BLACKLIST_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTER_BLACKLIST_UPDATED_AUDIT BackupEventTypeForGroup = "CLUSTER_BLACKLIST_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RS_SNAPSHOT_SCHEDULE_UPDATED_AUDIT BackupEventTypeForGroup = "RS_SNAPSHOT_SCHEDULE_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTER_SNAPSHOT_SCHEDULE_UPDATED_AUDIT BackupEventTypeForGroup = "CLUSTER_SNAPSHOT_SCHEDULE_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTER_CHECKKPOINT_UPDATED_AUDIT BackupEventTypeForGroup = "CLUSTER_CHECKKPOINT_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RS_STORAGE_ENGINE_UPDATED_AUDIT BackupEventTypeForGroup = "RS_STORAGE_ENGINE_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTER_STORAGE_ENGINE_UPDATED_AUDIT BackupEventTypeForGroup = "CLUSTER_STORAGE_ENGINE_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_RS_ROTATE_MASTER_KEY_AUDIT BackupEventTypeForGroup = "RS_ROTATE_MASTER_KEY_AUDIT"
	BACKUPEVENTTYPEFORGROUP_SNAPSHOT_EXPIRY_UPDATED_AUDIT BackupEventTypeForGroup = "SNAPSHOT_EXPIRY_UPDATED_AUDIT"
	BACKUPEVENTTYPEFORGROUP_CLUSTERSHOT_EXPIRY_UPDATED_AUDIT BackupEventTypeForGroup = "CLUSTERSHOT_EXPIRY_UPDATED_AUDIT"
)

// All allowed values of BackupEventTypeForGroup enum
var AllowedBackupEventTypeForGroupEnumValues = []BackupEventTypeForGroup{
	"OPLOG_CURRENT",
	"OPLOG_BEHIND",
	"RESYNC_PERFORMED",
	"RESYNC_REQUIRED",
	"CONSISTENT_BACKUP_CONFIGURATION",
	"INCONSISTENT_BACKUP_CONFIGURATION",
	"GOOD_CLUSTERSHOT",
	"BAD_CLUSTERSHOTS",
	"INITIAL_SYNC_STARTED_AUDIT",
	"INITIAL_SYNC_FINISHED_AUDIT",
	"RS_STATE_CHANGED_AUDIT",
	"CLUSTER_STATE_CHANGED_AUDIT",
	"RESTORE_REQUESTED_AUDIT",
	"SYNC_REQUIRED_AUDIT",
	"SYNC_PENDING_AUDIT",
	"CLUSTERSHOT_DELETED_AUDIT",
	"SNAPSHOT_DELETED_AUDIT",
	"RS_CREDENTIAL_UPDATED_AUDIT",
	"CLUSTER_CREDENTIAL_UPDATED_AUDIT",
	"RS_BLACKLIST_UPDATED_AUDIT",
	"CLUSTER_BLACKLIST_UPDATED_AUDIT",
	"RS_SNAPSHOT_SCHEDULE_UPDATED_AUDIT",
	"CLUSTER_SNAPSHOT_SCHEDULE_UPDATED_AUDIT",
	"CLUSTER_CHECKKPOINT_UPDATED_AUDIT",
	"RS_STORAGE_ENGINE_UPDATED_AUDIT",
	"CLUSTER_STORAGE_ENGINE_UPDATED_AUDIT",
	"RS_ROTATE_MASTER_KEY_AUDIT",
	"SNAPSHOT_EXPIRY_UPDATED_AUDIT",
	"CLUSTERSHOT_EXPIRY_UPDATED_AUDIT",
}

func (v *BackupEventTypeForGroup) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := BackupEventTypeForGroup(value)
	for _, existing := range AllowedBackupEventTypeForGroupEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid BackupEventTypeForGroup", value)
}

// NewBackupEventTypeForGroupFromValue returns a pointer to a valid BackupEventTypeForGroup
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewBackupEventTypeForGroupFromValue(v string) (*BackupEventTypeForGroup, error) {
	ev := BackupEventTypeForGroup(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for BackupEventTypeForGroup: valid values are %v", v, AllowedBackupEventTypeForGroupEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v BackupEventTypeForGroup) IsValid() bool {
	for _, existing := range AllowedBackupEventTypeForGroupEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to BackupEventTypeForGroup value
func (v BackupEventTypeForGroup) Ptr() *BackupEventTypeForGroup {
	return &v
}

type NullableBackupEventTypeForGroup struct {
	value *BackupEventTypeForGroup
	isSet bool
}

func (v NullableBackupEventTypeForGroup) Get() *BackupEventTypeForGroup {
	return v.value
}

func (v *NullableBackupEventTypeForGroup) Set(val *BackupEventTypeForGroup) {
	v.value = val
	v.isSet = true
}

func (v NullableBackupEventTypeForGroup) IsSet() bool {
	return v.isSet
}

func (v *NullableBackupEventTypeForGroup) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBackupEventTypeForGroup(val *BackupEventTypeForGroup) *NullableBackupEventTypeForGroup {
	return &NullableBackupEventTypeForGroup{value: val, isSet: true}
}

func (v NullableBackupEventTypeForGroup) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBackupEventTypeForGroup) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

