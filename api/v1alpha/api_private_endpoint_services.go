/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type PrivateEndpointServicesApi interface {

	/*
	CreateOnePrivateEndpointForOneProvider Create One Private Endpoint for One Provider

	Creates one private resource in the specified private resource service hosted from one cloud service provider. This cloud service provider manages the private resource service for the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param cloudProvider Cloud service provider that manages this private endpoint.
	@param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service for which you want to create a private endpoint.
	@return PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest
	*/
	CreateOnePrivateEndpointForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointServiceId string) PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest

	// CreateOnePrivateEndpointForOneProviderExecute executes the request
	//  @return Endpoint
	CreateOnePrivateEndpointForOneProviderExecute(r PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest) (*Endpoint, *http.Response, error)

	/*
	CreateOnePrivateEndpointServiceForOneProvider Create One Private Endpoint Service for One Provider

	Creates one private resource service for the specified cloud service provider. This cloud service provider manages the private resource service for the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest
	*/
	CreateOnePrivateEndpointServiceForOneProvider(ctx context.Context, groupId string) PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest

	// CreateOnePrivateEndpointServiceForOneProviderExecute executes the request
	//  @return EndpointService
	CreateOnePrivateEndpointServiceForOneProviderExecute(r PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest) (*EndpointService, *http.Response, error)

	/*
	RemoveOnePrivateEndpointForOneProvider Remove One Private Endpoint for One Provider

	Removes one private resource from the specified project. This cloud service provider manages the private resource service that manages the private resource that belongs to the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param cloudProvider Cloud service provider that manages this private endpoint.
	@param endpointId Unique string that identifies the private endpoint you want to delete. The format of the **endpointId** parameter differs for AWS and Azure. You must URL encode the **endpointId** for Azure private endpoints.
	@param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service from which you want to delete a private endpoint.
	@return PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest
	*/
	RemoveOnePrivateEndpointForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointId string, endpointServiceId string) PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest

	// RemoveOnePrivateEndpointForOneProviderExecute executes the request
	RemoveOnePrivateEndpointForOneProviderExecute(r PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest) (*http.Response, error)

	/*
	RemoveOnePrivateEndpointServiceForOneProvider Remove One Private Endpoint Service for One Provider

	Removes one private resource service from the specified project. This cloud service provider manages the private resource service that belongs to the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param cloudProvider Cloud service provider that manages this private endpoint service.
	@param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service that you want to delete.
	@return PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest
	*/
	RemoveOnePrivateEndpointServiceForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointServiceId string) PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest

	// RemoveOnePrivateEndpointServiceForOneProviderExecute executes the request
	RemoveOnePrivateEndpointServiceForOneProviderExecute(r PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest) (*http.Response, error)

	/*
	ReturnAllPrivateEndpointServicesForOneProvider Return All Private Endpoint Services for One Provider

	Returns the name, interfaces, and state of all private resource services for the specified cloud service provider. This cloud service provider manages the private resource service for the project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param cloudProvider Cloud service provider that manages this private endpoint service.
	@return PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest
	*/
	ReturnAllPrivateEndpointServicesForOneProvider(ctx context.Context, groupId string, cloudProvider string) PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest

	// ReturnAllPrivateEndpointServicesForOneProviderExecute executes the request
	//  @return PaginatedPrivateLinkConnectionView
	ReturnAllPrivateEndpointServicesForOneProviderExecute(r PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest) (*PaginatedPrivateLinkConnectionView, *http.Response, error)

	/*
	ReturnOnePrivateEndpointForOneProvider Return One Private Endpoint for One Provider

	Returns the connection state of the specified private resource. The private resource service manages this private resource which belongs to one project hosted from one cloud service provider. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param cloudProvider Cloud service provider that manages this private endpoint.
	@param endpointId Unique string that identifies the private endpoint you want to return. The format of the **endpointId** parameter differs for AWS and Azure. You must URL encode the **endpointId** for Azure private endpoints.
	@param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service for which you want to return a private endpoint.
	@return PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest
	*/
	ReturnOnePrivateEndpointForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointId string, endpointServiceId string) PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest

	// ReturnOnePrivateEndpointForOneProviderExecute executes the request
	//  @return Endpoint
	ReturnOnePrivateEndpointForOneProviderExecute(r PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest) (*Endpoint, *http.Response, error)

	/*
	ReturnOnePrivateEndpointServiceForOneProvider Return One Private Endpoint Service for One Provider

	Returns the name, interfaces, and state of the specified private resource service from one project. The cloud service provider hosted this private resource service that belongs to the project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param cloudProvider Cloud service provider that manages this private endpoint service.
	@param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service that you want to return.
	@return PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest
	*/
	ReturnOnePrivateEndpointServiceForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointServiceId string) PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest

	// ReturnOnePrivateEndpointServiceForOneProviderExecute executes the request
	//  @return EndpointService
	ReturnOnePrivateEndpointServiceForOneProviderExecute(r PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest) (*EndpointService, *http.Response, error)

	/*
	ReturnRegionalizedPrivateEndpointStatus Return Regionalized Private Endpoint Status

	Checks whether each region in the specified cloud service provider can create multiple private resources per region. The cloud service provider manages the private resource for the project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest
	*/
	ReturnRegionalizedPrivateEndpointStatus(ctx context.Context, groupId string) PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest

	// ReturnRegionalizedPrivateEndpointStatusExecute executes the request
	//  @return ProjectSettingItemView
	ReturnRegionalizedPrivateEndpointStatusExecute(r PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest) (*ProjectSettingItemView, *http.Response, error)

	/*
	ToggleRegionalizedPrivateEndpointStatus Toggle Regionalized Private Endpoint Status

	Enables or disables the ability can create multiple private resources per region in all cloud service providers in one project. The cloud service provider manages the private resource for the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest
	*/
	ToggleRegionalizedPrivateEndpointStatus(ctx context.Context, groupId string) PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest

	// ToggleRegionalizedPrivateEndpointStatusExecute executes the request
	//  @return ProjectSettingItemView
	ToggleRegionalizedPrivateEndpointStatusExecute(r PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest) (*ProjectSettingItemView, *http.Response, error)
}

// PrivateEndpointServicesApiService PrivateEndpointServicesApi service
type PrivateEndpointServicesApiService service

type PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	cloudProvider string
	endpointServiceId string
	createOnePrivateEndpointForOneProviderRequest *CreateOnePrivateEndpointForOneProviderRequest
	envelope *bool
	pretty *bool
}

// Creates one private resource endpoint for the specified cloud service provider.
func (r PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest) CreateOnePrivateEndpointForOneProviderRequest(createOnePrivateEndpointForOneProviderRequest CreateOnePrivateEndpointForOneProviderRequest) PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest {
	r.createOnePrivateEndpointForOneProviderRequest = &createOnePrivateEndpointForOneProviderRequest
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest) Execute() (*Endpoint, *http.Response, error) {
	return r.ApiService.CreateOnePrivateEndpointForOneProviderExecute(r)
}

/*
CreateOnePrivateEndpointForOneProvider Create One Private Endpoint for One Provider

Creates one private resource in the specified private resource service hosted from one cloud service provider. This cloud service provider manages the private resource service for the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param cloudProvider Cloud service provider that manages this private endpoint.
 @param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service for which you want to create a private endpoint.
 @return PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) CreateOnePrivateEndpointForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointServiceId string) PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest {
	return PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		cloudProvider: cloudProvider,
		endpointServiceId: endpointServiceId,
	}
}

// Execute executes the request
//  @return Endpoint
func (a *PrivateEndpointServicesApiService) CreateOnePrivateEndpointForOneProviderExecute(r PrivateEndpointServicesApiCreateOnePrivateEndpointForOneProviderRequest) (*Endpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Endpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.CreateOnePrivateEndpointForOneProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/{cloudProvider}/endpointService/{endpointServiceId}/endpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointServiceId"+"}", url.PathEscape(parameterToString(r.endpointServiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.endpointServiceId) < 24 {
		return localVarReturnValue, nil, reportError("endpointServiceId must have at least 24 elements")
	}
	if strlen(r.endpointServiceId) > 24 {
		return localVarReturnValue, nil, reportError("endpointServiceId must have less than 24 elements")
	}
	if r.createOnePrivateEndpointForOneProviderRequest == nil {
		return localVarReturnValue, nil, reportError("createOnePrivateEndpointForOneProviderRequest is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOnePrivateEndpointForOneProviderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	createEndpointServiceRequest *CreateEndpointServiceRequest
	envelope *bool
	pretty *bool
}

// Creates one private resource service for the specified cloud service provider.
func (r PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest) CreateEndpointServiceRequest(createEndpointServiceRequest CreateEndpointServiceRequest) PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest {
	r.createEndpointServiceRequest = &createEndpointServiceRequest
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest) Execute() (*EndpointService, *http.Response, error) {
	return r.ApiService.CreateOnePrivateEndpointServiceForOneProviderExecute(r)
}

/*
CreateOnePrivateEndpointServiceForOneProvider Create One Private Endpoint Service for One Provider

Creates one private resource service for the specified cloud service provider. This cloud service provider manages the private resource service for the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) CreateOnePrivateEndpointServiceForOneProvider(ctx context.Context, groupId string) PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest {
	return PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return EndpointService
func (a *PrivateEndpointServicesApiService) CreateOnePrivateEndpointServiceForOneProviderExecute(r PrivateEndpointServicesApiCreateOnePrivateEndpointServiceForOneProviderRequest) (*EndpointService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.CreateOnePrivateEndpointServiceForOneProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/endpointService"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if r.createEndpointServiceRequest == nil {
		return localVarReturnValue, nil, reportError("createEndpointServiceRequest is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEndpointServiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	cloudProvider string
	endpointId string
	endpointServiceId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOnePrivateEndpointForOneProviderExecute(r)
}

/*
RemoveOnePrivateEndpointForOneProvider Remove One Private Endpoint for One Provider

Removes one private resource from the specified project. This cloud service provider manages the private resource service that manages the private resource that belongs to the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param cloudProvider Cloud service provider that manages this private endpoint.
 @param endpointId Unique string that identifies the private endpoint you want to delete. The format of the **endpointId** parameter differs for AWS and Azure. You must URL encode the **endpointId** for Azure private endpoints.
 @param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service from which you want to delete a private endpoint.
 @return PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) RemoveOnePrivateEndpointForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointId string, endpointServiceId string) PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest {
	return PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		cloudProvider: cloudProvider,
		endpointId: endpointId,
		endpointServiceId: endpointServiceId,
	}
}

// Execute executes the request
func (a *PrivateEndpointServicesApiService) RemoveOnePrivateEndpointForOneProviderExecute(r PrivateEndpointServicesApiRemoveOnePrivateEndpointForOneProviderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.RemoveOnePrivateEndpointForOneProvider")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/{cloudProvider}/endpointService/{endpointServiceId}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointServiceId"+"}", url.PathEscape(parameterToString(r.endpointServiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.endpointServiceId) < 24 {
		return nil, reportError("endpointServiceId must have at least 24 elements")
	}
	if strlen(r.endpointServiceId) > 24 {
		return nil, reportError("endpointServiceId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	cloudProvider string
	endpointServiceId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOnePrivateEndpointServiceForOneProviderExecute(r)
}

/*
RemoveOnePrivateEndpointServiceForOneProvider Remove One Private Endpoint Service for One Provider

Removes one private resource service from the specified project. This cloud service provider manages the private resource service that belongs to the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param cloudProvider Cloud service provider that manages this private endpoint service.
 @param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service that you want to delete.
 @return PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) RemoveOnePrivateEndpointServiceForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointServiceId string) PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest {
	return PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		cloudProvider: cloudProvider,
		endpointServiceId: endpointServiceId,
	}
}

// Execute executes the request
func (a *PrivateEndpointServicesApiService) RemoveOnePrivateEndpointServiceForOneProviderExecute(r PrivateEndpointServicesApiRemoveOnePrivateEndpointServiceForOneProviderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.RemoveOnePrivateEndpointServiceForOneProvider")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/{cloudProvider}/endpointService/{endpointServiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointServiceId"+"}", url.PathEscape(parameterToString(r.endpointServiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.endpointServiceId) < 24 {
		return nil, reportError("endpointServiceId must have at least 24 elements")
	}
	if strlen(r.endpointServiceId) > 24 {
		return nil, reportError("endpointServiceId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	cloudProvider string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest) Execute() (*PaginatedPrivateLinkConnectionView, *http.Response, error) {
	return r.ApiService.ReturnAllPrivateEndpointServicesForOneProviderExecute(r)
}

/*
ReturnAllPrivateEndpointServicesForOneProvider Return All Private Endpoint Services for One Provider

Returns the name, interfaces, and state of all private resource services for the specified cloud service provider. This cloud service provider manages the private resource service for the project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param cloudProvider Cloud service provider that manages this private endpoint service.
 @return PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) ReturnAllPrivateEndpointServicesForOneProvider(ctx context.Context, groupId string, cloudProvider string) PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest {
	return PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		cloudProvider: cloudProvider,
	}
}

// Execute executes the request
//  @return PaginatedPrivateLinkConnectionView
func (a *PrivateEndpointServicesApiService) ReturnAllPrivateEndpointServicesForOneProviderExecute(r PrivateEndpointServicesApiReturnAllPrivateEndpointServicesForOneProviderRequest) (*PaginatedPrivateLinkConnectionView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPrivateLinkConnectionView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.ReturnAllPrivateEndpointServicesForOneProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/{cloudProvider}/endpointService"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	cloudProvider string
	endpointId string
	endpointServiceId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest) Execute() (*Endpoint, *http.Response, error) {
	return r.ApiService.ReturnOnePrivateEndpointForOneProviderExecute(r)
}

/*
ReturnOnePrivateEndpointForOneProvider Return One Private Endpoint for One Provider

Returns the connection state of the specified private resource. The private resource service manages this private resource which belongs to one project hosted from one cloud service provider. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param cloudProvider Cloud service provider that manages this private endpoint.
 @param endpointId Unique string that identifies the private endpoint you want to return. The format of the **endpointId** parameter differs for AWS and Azure. You must URL encode the **endpointId** for Azure private endpoints.
 @param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service for which you want to return a private endpoint.
 @return PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) ReturnOnePrivateEndpointForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointId string, endpointServiceId string) PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest {
	return PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		cloudProvider: cloudProvider,
		endpointId: endpointId,
		endpointServiceId: endpointServiceId,
	}
}

// Execute executes the request
//  @return Endpoint
func (a *PrivateEndpointServicesApiService) ReturnOnePrivateEndpointForOneProviderExecute(r PrivateEndpointServicesApiReturnOnePrivateEndpointForOneProviderRequest) (*Endpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Endpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.ReturnOnePrivateEndpointForOneProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/{cloudProvider}/endpointService/{endpointServiceId}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointServiceId"+"}", url.PathEscape(parameterToString(r.endpointServiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.endpointServiceId) < 24 {
		return localVarReturnValue, nil, reportError("endpointServiceId must have at least 24 elements")
	}
	if strlen(r.endpointServiceId) > 24 {
		return localVarReturnValue, nil, reportError("endpointServiceId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	cloudProvider string
	endpointServiceId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest) Envelope(envelope bool) PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest) Pretty(pretty bool) PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest) Execute() (*EndpointService, *http.Response, error) {
	return r.ApiService.ReturnOnePrivateEndpointServiceForOneProviderExecute(r)
}

/*
ReturnOnePrivateEndpointServiceForOneProvider Return One Private Endpoint Service for One Provider

Returns the name, interfaces, and state of the specified private resource service from one project. The cloud service provider hosted this private resource service that belongs to the project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param cloudProvider Cloud service provider that manages this private endpoint service.
 @param endpointServiceId Unique 24-hexadecimal digit string that identifies the private endpoint service that you want to return.
 @return PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest
*/
func (a *PrivateEndpointServicesApiService) ReturnOnePrivateEndpointServiceForOneProvider(ctx context.Context, groupId string, cloudProvider string, endpointServiceId string) PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest {
	return PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		cloudProvider: cloudProvider,
		endpointServiceId: endpointServiceId,
	}
}

// Execute executes the request
//  @return EndpointService
func (a *PrivateEndpointServicesApiService) ReturnOnePrivateEndpointServiceForOneProviderExecute(r PrivateEndpointServicesApiReturnOnePrivateEndpointServiceForOneProviderRequest) (*EndpointService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.ReturnOnePrivateEndpointServiceForOneProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/{cloudProvider}/endpointService/{endpointServiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointServiceId"+"}", url.PathEscape(parameterToString(r.endpointServiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.endpointServiceId) < 24 {
		return localVarReturnValue, nil, reportError("endpointServiceId must have at least 24 elements")
	}
	if strlen(r.endpointServiceId) > 24 {
		return localVarReturnValue, nil, reportError("endpointServiceId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest) Envelope(envelope bool) PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest) Pretty(pretty bool) PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest) Execute() (*ProjectSettingItemView, *http.Response, error) {
	return r.ApiService.ReturnRegionalizedPrivateEndpointStatusExecute(r)
}

/*
ReturnRegionalizedPrivateEndpointStatus Return Regionalized Private Endpoint Status

Checks whether each region in the specified cloud service provider can create multiple private resources per region. The cloud service provider manages the private resource for the project. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest
*/
func (a *PrivateEndpointServicesApiService) ReturnRegionalizedPrivateEndpointStatus(ctx context.Context, groupId string) PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest {
	return PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ProjectSettingItemView
func (a *PrivateEndpointServicesApiService) ReturnRegionalizedPrivateEndpointStatusExecute(r PrivateEndpointServicesApiReturnRegionalizedPrivateEndpointStatusRequest) (*ProjectSettingItemView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectSettingItemView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.ReturnRegionalizedPrivateEndpointStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/regionalMode"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest struct {
	ctx context.Context
	ApiService PrivateEndpointServicesApi
	groupId string
	projectSettingItemView *ProjectSettingItemView
	envelope *bool
	pretty *bool
}

// Enables or disables the ability can create multiple private resources per region in all cloud service providers in one project.
func (r PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest) ProjectSettingItemView(projectSettingItemView ProjectSettingItemView) PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest {
	r.projectSettingItemView = &projectSettingItemView
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest) Envelope(envelope bool) PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest) Pretty(pretty bool) PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest {
	r.pretty = &pretty
	return r
}

func (r PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest) Execute() (*ProjectSettingItemView, *http.Response, error) {
	return r.ApiService.ToggleRegionalizedPrivateEndpointStatusExecute(r)
}

/*
ToggleRegionalizedPrivateEndpointStatus Toggle Regionalized Private Endpoint Status

Enables or disables the ability can create multiple private resources per region in all cloud service providers in one project. The cloud service provider manages the private resource for the project. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest
*/
func (a *PrivateEndpointServicesApiService) ToggleRegionalizedPrivateEndpointStatus(ctx context.Context, groupId string) PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest {
	return PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ProjectSettingItemView
func (a *PrivateEndpointServicesApiService) ToggleRegionalizedPrivateEndpointStatusExecute(r PrivateEndpointServicesApiToggleRegionalizedPrivateEndpointStatusRequest) (*ProjectSettingItemView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectSettingItemView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrivateEndpointServicesApiService.ToggleRegionalizedPrivateEndpointStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/regionalMode"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if r.projectSettingItemView == nil {
		return localVarReturnValue, nil, reportError("projectSettingItemView is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.projectSettingItemView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
