/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1alpha

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


type EventsApi interface {

	/*
	ReturnAllEventsFromOneOrganization Return All Events from One Organization

	Returns all events for the specified organization. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-orgs-get-all/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
	@return EventsApiReturnAllEventsFromOneOrganizationRequest
	*/
	ReturnAllEventsFromOneOrganization(ctx context.Context, orgId string) EventsApiReturnAllEventsFromOneOrganizationRequest

	// ReturnAllEventsFromOneOrganizationExecute executes the request
	//  @return OrgPaginatedEventView
	ReturnAllEventsFromOneOrganizationExecute(r EventsApiReturnAllEventsFromOneOrganizationRequest) (*OrgPaginatedEventView, *http.Response, error)

	/*
	ReturnAllEventsFromOneProject Return All Events from One Project

	Returns one event for the specified project. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-projects-get-all/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return EventsApiReturnAllEventsFromOneProjectRequest
	*/
	ReturnAllEventsFromOneProject(ctx context.Context, groupId string) EventsApiReturnAllEventsFromOneProjectRequest

	// ReturnAllEventsFromOneProjectExecute executes the request
	//  @return GroupPaginatedEventView
	ReturnAllEventsFromOneProjectExecute(r EventsApiReturnAllEventsFromOneProjectRequest) (*GroupPaginatedEventView, *http.Response, error)

	/*
	ReturnOneEventFromOneOrganization Return One Event from One Organization

	Returns one event for the specified organization. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-orgs-get-one/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
	@param eventId Unique 24-hexadecimal digit string that identifies the event that you want to return. Use the [/events](#tag/Events/operation/returnAllEventsFromOneOrganization) endpoint to retrieve all events to which the authenticated user has access.
	@return EventsApiReturnOneEventFromOneOrganizationRequest
	*/
	ReturnOneEventFromOneOrganization(ctx context.Context, orgId string, eventId string) EventsApiReturnOneEventFromOneOrganizationRequest

	// ReturnOneEventFromOneOrganizationExecute executes the request
	//  @return EventViewForOrg
	ReturnOneEventFromOneOrganizationExecute(r EventsApiReturnOneEventFromOneOrganizationRequest) (*EventViewForOrg, *http.Response, error)

	/*
	ReturnOneEventFromOneProject Return One Event from One Project

	Returns one event for the specified project. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-projects-get-one/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param eventId Unique 24-hexadecimal digit string that identifies the event that you want to return. Use the [/events](#tag/Events/operation/returnAllEventsFromOneProject) endpoint to retrieve all events to which the authenticated user has access.
	@return EventsApiReturnOneEventFromOneProjectRequest
	*/
	ReturnOneEventFromOneProject(ctx context.Context, groupId string, eventId string) EventsApiReturnOneEventFromOneProjectRequest

	// ReturnOneEventFromOneProjectExecute executes the request
	//  @return EventViewForGroup
	ReturnOneEventFromOneProjectExecute(r EventsApiReturnOneEventFromOneProjectRequest) (*EventViewForGroup, *http.Response, error)
}

// EventsApiService EventsApi service
type EventsApiService service

type EventsApiReturnAllEventsFromOneOrganizationRequest struct {
	ctx context.Context
	ApiService EventsApi
	orgId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
	eventType *EventTypeForOrg
	includeRaw *bool
	maxDate *time.Time
	minDate *time.Time
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) Envelope(envelope bool) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) IncludeCount(includeCount bool) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) ItemsPerPage(itemsPerPage int32) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) PageNum(pageNum int32) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) Pretty(pretty bool) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.pretty = &pretty
	return r
}

// Category of incident recorded at this moment in time.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) EventType(eventType EventTypeForOrg) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.eventType = &eventType
	return r
}

// Flag that indicates whether to include the raw document in the output. The raw document contains additional meta information about the event.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) IncludeRaw(includeRaw bool) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.includeRaw = &includeRaw
	return r
}

// Date and time from when MongoDB Cloud stops returning events. This parameter uses the ISO 8601 timestamp format in UTC.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) MaxDate(maxDate time.Time) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.maxDate = &maxDate
	return r
}

// Date and time from when MongoDB Cloud starts returning events. This parameter uses the ISO 8601 timestamp format in UTC.
func (r EventsApiReturnAllEventsFromOneOrganizationRequest) MinDate(minDate time.Time) EventsApiReturnAllEventsFromOneOrganizationRequest {
	r.minDate = &minDate
	return r
}

func (r EventsApiReturnAllEventsFromOneOrganizationRequest) Execute() (*OrgPaginatedEventView, *http.Response, error) {
	return r.ApiService.ReturnAllEventsFromOneOrganizationExecute(r)
}

/*
ReturnAllEventsFromOneOrganization Return All Events from One Organization

Returns all events for the specified organization. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-orgs-get-all/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
 @return EventsApiReturnAllEventsFromOneOrganizationRequest
*/
func (a *EventsApiService) ReturnAllEventsFromOneOrganization(ctx context.Context, orgId string) EventsApiReturnAllEventsFromOneOrganizationRequest {
	return EventsApiReturnAllEventsFromOneOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return OrgPaginatedEventView
func (a *EventsApiService) ReturnAllEventsFromOneOrganizationExecute(r EventsApiReturnAllEventsFromOneOrganizationRequest) (*OrgPaginatedEventView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrgPaginatedEventView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.ReturnAllEventsFromOneOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.eventType != nil {
		localVarQueryParams.Add("eventType", parameterToString(*r.eventType, ""))
	}
	if r.includeRaw != nil {
		localVarQueryParams.Add("includeRaw", parameterToString(*r.includeRaw, ""))
	}
	if r.maxDate != nil {
		localVarQueryParams.Add("maxDate", parameterToString(*r.maxDate, ""))
	}
	if r.minDate != nil {
		localVarQueryParams.Add("minDate", parameterToString(*r.minDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventsApiReturnAllEventsFromOneProjectRequest struct {
	ctx context.Context
	ApiService EventsApi
	groupId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
	clusterNames *[]string
	eventType *EventTypeForGroup
	includeRaw *bool
	maxDate *time.Time
	minDate *time.Time
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r EventsApiReturnAllEventsFromOneProjectRequest) Envelope(envelope bool) EventsApiReturnAllEventsFromOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r EventsApiReturnAllEventsFromOneProjectRequest) IncludeCount(includeCount bool) EventsApiReturnAllEventsFromOneProjectRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r EventsApiReturnAllEventsFromOneProjectRequest) ItemsPerPage(itemsPerPage int32) EventsApiReturnAllEventsFromOneProjectRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r EventsApiReturnAllEventsFromOneProjectRequest) PageNum(pageNum int32) EventsApiReturnAllEventsFromOneProjectRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r EventsApiReturnAllEventsFromOneProjectRequest) Pretty(pretty bool) EventsApiReturnAllEventsFromOneProjectRequest {
	r.pretty = &pretty
	return r
}

// Human-readable label that identifies the cluster.
func (r EventsApiReturnAllEventsFromOneProjectRequest) ClusterNames(clusterNames []string) EventsApiReturnAllEventsFromOneProjectRequest {
	r.clusterNames = &clusterNames
	return r
}

// Category of incident recorded at this moment in time.
func (r EventsApiReturnAllEventsFromOneProjectRequest) EventType(eventType EventTypeForGroup) EventsApiReturnAllEventsFromOneProjectRequest {
	r.eventType = &eventType
	return r
}

// Flag that indicates whether to include the raw document in the output. The raw document contains additional meta information about the event.
func (r EventsApiReturnAllEventsFromOneProjectRequest) IncludeRaw(includeRaw bool) EventsApiReturnAllEventsFromOneProjectRequest {
	r.includeRaw = &includeRaw
	return r
}

// Date and time from when MongoDB Cloud stops returning events. This parameter uses the ISO 8601 timestamp format in UTC.
func (r EventsApiReturnAllEventsFromOneProjectRequest) MaxDate(maxDate time.Time) EventsApiReturnAllEventsFromOneProjectRequest {
	r.maxDate = &maxDate
	return r
}

// Date and time from when MongoDB Cloud starts returning events. This parameter uses the ISO 8601 timestamp format in UTC.
func (r EventsApiReturnAllEventsFromOneProjectRequest) MinDate(minDate time.Time) EventsApiReturnAllEventsFromOneProjectRequest {
	r.minDate = &minDate
	return r
}

func (r EventsApiReturnAllEventsFromOneProjectRequest) Execute() (*GroupPaginatedEventView, *http.Response, error) {
	return r.ApiService.ReturnAllEventsFromOneProjectExecute(r)
}

/*
ReturnAllEventsFromOneProject Return All Events from One Project

Returns one event for the specified project. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-projects-get-all/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return EventsApiReturnAllEventsFromOneProjectRequest
*/
func (a *EventsApiService) ReturnAllEventsFromOneProject(ctx context.Context, groupId string) EventsApiReturnAllEventsFromOneProjectRequest {
	return EventsApiReturnAllEventsFromOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GroupPaginatedEventView
func (a *EventsApiService) ReturnAllEventsFromOneProjectExecute(r EventsApiReturnAllEventsFromOneProjectRequest) (*GroupPaginatedEventView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupPaginatedEventView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.ReturnAllEventsFromOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.clusterNames != nil {
		t := *r.clusterNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("clusterNames", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("clusterNames", parameterToString(t, "multi"))
		}
	}
	if r.eventType != nil {
		localVarQueryParams.Add("eventType", parameterToString(*r.eventType, ""))
	}
	if r.includeRaw != nil {
		localVarQueryParams.Add("includeRaw", parameterToString(*r.includeRaw, ""))
	}
	if r.maxDate != nil {
		localVarQueryParams.Add("maxDate", parameterToString(*r.maxDate, ""))
	}
	if r.minDate != nil {
		localVarQueryParams.Add("minDate", parameterToString(*r.minDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventsApiReturnOneEventFromOneOrganizationRequest struct {
	ctx context.Context
	ApiService EventsApi
	orgId string
	eventId string
	envelope *bool
	pretty *bool
	includeRaw *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r EventsApiReturnOneEventFromOneOrganizationRequest) Envelope(envelope bool) EventsApiReturnOneEventFromOneOrganizationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r EventsApiReturnOneEventFromOneOrganizationRequest) Pretty(pretty bool) EventsApiReturnOneEventFromOneOrganizationRequest {
	r.pretty = &pretty
	return r
}

// Flag that indicates whether to include the raw document in the output. The raw document contains additional meta information about the event.
func (r EventsApiReturnOneEventFromOneOrganizationRequest) IncludeRaw(includeRaw bool) EventsApiReturnOneEventFromOneOrganizationRequest {
	r.includeRaw = &includeRaw
	return r
}

func (r EventsApiReturnOneEventFromOneOrganizationRequest) Execute() (*EventViewForOrg, *http.Response, error) {
	return r.ApiService.ReturnOneEventFromOneOrganizationExecute(r)
}

/*
ReturnOneEventFromOneOrganization Return One Event from One Organization

Returns one event for the specified organization. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Organization Member role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-orgs-get-one/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
 @param eventId Unique 24-hexadecimal digit string that identifies the event that you want to return. Use the [/events](#tag/Events/operation/returnAllEventsFromOneOrganization) endpoint to retrieve all events to which the authenticated user has access.
 @return EventsApiReturnOneEventFromOneOrganizationRequest
*/
func (a *EventsApiService) ReturnOneEventFromOneOrganization(ctx context.Context, orgId string, eventId string) EventsApiReturnOneEventFromOneOrganizationRequest {
	return EventsApiReturnOneEventFromOneOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return EventViewForOrg
func (a *EventsApiService) ReturnOneEventFromOneOrganizationExecute(r EventsApiReturnOneEventFromOneOrganizationRequest) (*EventViewForOrg, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventViewForOrg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.ReturnOneEventFromOneOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/orgs/{orgId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterToString(r.orgId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgId) < 24 {
		return localVarReturnValue, nil, reportError("orgId must have at least 24 elements")
	}
	if strlen(r.orgId) > 24 {
		return localVarReturnValue, nil, reportError("orgId must have less than 24 elements")
	}
	if strlen(r.eventId) < 24 {
		return localVarReturnValue, nil, reportError("eventId must have at least 24 elements")
	}
	if strlen(r.eventId) > 24 {
		return localVarReturnValue, nil, reportError("eventId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.includeRaw != nil {
		localVarQueryParams.Add("includeRaw", parameterToString(*r.includeRaw, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventsApiReturnOneEventFromOneProjectRequest struct {
	ctx context.Context
	ApiService EventsApi
	groupId string
	eventId string
	envelope *bool
	pretty *bool
	includeRaw *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r EventsApiReturnOneEventFromOneProjectRequest) Envelope(envelope bool) EventsApiReturnOneEventFromOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r EventsApiReturnOneEventFromOneProjectRequest) Pretty(pretty bool) EventsApiReturnOneEventFromOneProjectRequest {
	r.pretty = &pretty
	return r
}

// Flag that indicates whether to include the raw document in the output. The raw document contains additional meta information about the event.
func (r EventsApiReturnOneEventFromOneProjectRequest) IncludeRaw(includeRaw bool) EventsApiReturnOneEventFromOneProjectRequest {
	r.includeRaw = &includeRaw
	return r
}

func (r EventsApiReturnOneEventFromOneProjectRequest) Execute() (*EventViewForGroup, *http.Response, error) {
	return r.ApiService.ReturnOneEventFromOneProjectExecute(r)
}

/*
ReturnOneEventFromOneProject Return One Event from One Project

Returns one event for the specified project. Events identify significant database, billing, or security activities or status changes. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/events-projects-get-one/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param eventId Unique 24-hexadecimal digit string that identifies the event that you want to return. Use the [/events](#tag/Events/operation/returnAllEventsFromOneProject) endpoint to retrieve all events to which the authenticated user has access.
 @return EventsApiReturnOneEventFromOneProjectRequest
*/
func (a *EventsApiService) ReturnOneEventFromOneProject(ctx context.Context, groupId string, eventId string) EventsApiReturnOneEventFromOneProjectRequest {
	return EventsApiReturnOneEventFromOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return EventViewForGroup
func (a *EventsApiService) ReturnOneEventFromOneProjectExecute(r EventsApiReturnOneEventFromOneProjectRequest) (*EventViewForGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventViewForGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.ReturnOneEventFromOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.eventId) < 24 {
		return localVarReturnValue, nil, reportError("eventId must have at least 24 elements")
	}
	if strlen(r.eventId) > 24 {
		return localVarReturnValue, nil, reportError("eventId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.includeRaw != nil {
		localVarQueryParams.Add("includeRaw", parameterToString(*r.includeRaw, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
