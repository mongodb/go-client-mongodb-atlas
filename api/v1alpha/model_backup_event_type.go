/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1alpha

import (
	"encoding/json"
	"fmt"
)

// BackupEventType Incident that triggered this alert.
type BackupEventType string

// List of BackupEventType
const (
	BACKUPEVENTTYPE_OPLOG_CURRENT BackupEventType = "OPLOG_CURRENT"
	BACKUPEVENTTYPE_OPLOG_BEHIND BackupEventType = "OPLOG_BEHIND"
	BACKUPEVENTTYPE_RESYNC_PERFORMED BackupEventType = "RESYNC_PERFORMED"
	BACKUPEVENTTYPE_RESYNC_REQUIRED BackupEventType = "RESYNC_REQUIRED"
	BACKUPEVENTTYPE_NO_RS_BIND_ERROR BackupEventType = "NO_RS_BIND_ERROR"
	BACKUPEVENTTYPE_RS_BIND_ERROR BackupEventType = "RS_BIND_ERROR"
	BACKUPEVENTTYPE_BACKUP_RECOVERED BackupEventType = "BACKUP_RECOVERED"
	BACKUPEVENTTYPE_BACKUP_TOO_MANY_RETRIES BackupEventType = "BACKUP_TOO_MANY_RETRIES"
	BACKUPEVENTTYPE_BACKUP_TOO_MANY_HEAD_START_ATTEMPTS BackupEventType = "BACKUP_TOO_MANY_HEAD_START_ATTEMPTS"
	BACKUPEVENTTYPE_BACKUP_IN_UNEXPECTED_STATE BackupEventType = "BACKUP_IN_UNEXPECTED_STATE"
	BACKUPEVENTTYPE_TIMELY_SNAPSHOT BackupEventType = "TIMELY_SNAPSHOT"
	BACKUPEVENTTYPE_LATE_SNAPSHOT BackupEventType = "LATE_SNAPSHOT"
	BACKUPEVENTTYPE_TIMELY_WTC_SNAPSHOT BackupEventType = "TIMELY_WTC_SNAPSHOT"
	BACKUPEVENTTYPE_LATE_WTC_SNAPSHOT BackupEventType = "LATE_WTC_SNAPSHOT"
	BACKUPEVENTTYPE_CONSISTENT_BACKUP_CONFIGURATION BackupEventType = "CONSISTENT_BACKUP_CONFIGURATION"
	BACKUPEVENTTYPE_INCONSISTENT_BACKUP_CONFIGURATION BackupEventType = "INCONSISTENT_BACKUP_CONFIGURATION"
	BACKUPEVENTTYPE_DAEMON_AVAILABLE_FOR_QUERYABLE_RESTORE_JOB BackupEventType = "DAEMON_AVAILABLE_FOR_QUERYABLE_RESTORE_JOB"
	BACKUPEVENTTYPE_NO_DAEMON_AVAILABLE_FOR_QUERYABLE_RESTORE_JOB BackupEventType = "NO_DAEMON_AVAILABLE_FOR_QUERYABLE_RESTORE_JOB"
	BACKUPEVENTTYPE_GOOD_CLUSTERSHOT BackupEventType = "GOOD_CLUSTERSHOT"
	BACKUPEVENTTYPE_BAD_CLUSTERSHOTS BackupEventType = "BAD_CLUSTERSHOTS"
	BACKUPEVENTTYPE_SYNC_SLICE_PROGRESSED BackupEventType = "SYNC_SLICE_PROGRESSED"
	BACKUPEVENTTYPE_SYNC_SLICE_HAS_NOT_PROGRESSED BackupEventType = "SYNC_SLICE_HAS_NOT_PROGRESSED"
	BACKUPEVENTTYPE_BACKUP_JOB_NOT_BUSY BackupEventType = "BACKUP_JOB_NOT_BUSY"
	BACKUPEVENTTYPE_BACKUP_JOB_TOO_BUSY BackupEventType = "BACKUP_JOB_TOO_BUSY"
	BACKUPEVENTTYPE_BACKUP_NOT_LATE_TRACKING_JOB BackupEventType = "BACKUP_NOT_LATE_TRACKING_JOB"
	BACKUPEVENTTYPE_BACKUP_LATE_TRACKING_JOB BackupEventType = "BACKUP_LATE_TRACKING_JOB"
	BACKUPEVENTTYPE_BACKUP_NOT_LATE_INTEGRITY_CHECK_JOB BackupEventType = "BACKUP_NOT_LATE_INTEGRITY_CHECK_JOB"
	BACKUPEVENTTYPE_BACKUP_LATE_INTEGRITY_CHECK_JOB BackupEventType = "BACKUP_LATE_INTEGRITY_CHECK_JOB"
	BACKUPEVENTTYPE_BACKUP_NOT_LATE_GROOM_JOB BackupEventType = "BACKUP_NOT_LATE_GROOM_JOB"
	BACKUPEVENTTYPE_BACKUP_LATE_GROOM_JOB BackupEventType = "BACKUP_LATE_GROOM_JOB"
	BACKUPEVENTTYPE_BLOCKSTORE_JOB_RECOVERED BackupEventType = "BLOCKSTORE_JOB_RECOVERED"
	BACKUPEVENTTYPE_BLOCKSTORE_JOB_TOO_MANY_RETRIES BackupEventType = "BLOCKSTORE_JOB_TOO_MANY_RETRIES"
	BACKUPEVENTTYPE_INITIAL_SYNC_STARTED_AUDIT BackupEventType = "INITIAL_SYNC_STARTED_AUDIT"
	BACKUPEVENTTYPE_INITIAL_SYNC_FINISHED_AUDIT BackupEventType = "INITIAL_SYNC_FINISHED_AUDIT"
	BACKUPEVENTTYPE_RS_STATE_CHANGED_AUDIT BackupEventType = "RS_STATE_CHANGED_AUDIT"
	BACKUPEVENTTYPE_CLUSTER_STATE_CHANGED_AUDIT BackupEventType = "CLUSTER_STATE_CHANGED_AUDIT"
	BACKUPEVENTTYPE_RESTORE_REQUESTED_AUDIT BackupEventType = "RESTORE_REQUESTED_AUDIT"
	BACKUPEVENTTYPE_INTERNAL_DIAGNOSTIC_RESTORE_REQUESTED_AUDIT BackupEventType = "INTERNAL_DIAGNOSTIC_RESTORE_REQUESTED_AUDIT"
	BACKUPEVENTTYPE_SYNC_REQUIRED_AUDIT BackupEventType = "SYNC_REQUIRED_AUDIT"
	BACKUPEVENTTYPE_SYNC_PENDING_AUDIT BackupEventType = "SYNC_PENDING_AUDIT"
	BACKUPEVENTTYPE_CLUSTERSHOT_DELETED_AUDIT BackupEventType = "CLUSTERSHOT_DELETED_AUDIT"
	BACKUPEVENTTYPE_SNAPSHOT_DELETED_AUDIT BackupEventType = "SNAPSHOT_DELETED_AUDIT"
	BACKUPEVENTTYPE_RS_CREDENTIAL_UPDATED_AUDIT BackupEventType = "RS_CREDENTIAL_UPDATED_AUDIT"
	BACKUPEVENTTYPE_CLUSTER_CREDENTIAL_UPDATED_AUDIT BackupEventType = "CLUSTER_CREDENTIAL_UPDATED_AUDIT"
	BACKUPEVENTTYPE_RS_BLACKLIST_UPDATED_AUDIT BackupEventType = "RS_BLACKLIST_UPDATED_AUDIT"
	BACKUPEVENTTYPE_CLUSTER_BLACKLIST_UPDATED_AUDIT BackupEventType = "CLUSTER_BLACKLIST_UPDATED_AUDIT"
	BACKUPEVENTTYPE_RS_SNAPSHOT_SCHEDULE_UPDATED_AUDIT BackupEventType = "RS_SNAPSHOT_SCHEDULE_UPDATED_AUDIT"
	BACKUPEVENTTYPE_CLUSTER_SNAPSHOT_SCHEDULE_UPDATED_AUDIT BackupEventType = "CLUSTER_SNAPSHOT_SCHEDULE_UPDATED_AUDIT"
	BACKUPEVENTTYPE_CLUSTER_CHECKKPOINT_UPDATED_AUDIT BackupEventType = "CLUSTER_CHECKKPOINT_UPDATED_AUDIT"
	BACKUPEVENTTYPE_RS_STORAGE_ENGINE_UPDATED_AUDIT BackupEventType = "RS_STORAGE_ENGINE_UPDATED_AUDIT"
	BACKUPEVENTTYPE_CLUSTER_STORAGE_ENGINE_UPDATED_AUDIT BackupEventType = "CLUSTER_STORAGE_ENGINE_UPDATED_AUDIT"
	BACKUPEVENTTYPE_RS_ROTATE_MASTER_KEY_AUDIT BackupEventType = "RS_ROTATE_MASTER_KEY_AUDIT"
	BACKUPEVENTTYPE_SNAPSHOT_EXPIRY_UPDATED_AUDIT BackupEventType = "SNAPSHOT_EXPIRY_UPDATED_AUDIT"
	BACKUPEVENTTYPE_CLUSTERSHOT_EXPIRY_UPDATED_AUDIT BackupEventType = "CLUSTERSHOT_EXPIRY_UPDATED_AUDIT"
)

// All allowed values of BackupEventType enum
var AllowedBackupEventTypeEnumValues = []BackupEventType{
	"OPLOG_CURRENT",
	"OPLOG_BEHIND",
	"RESYNC_PERFORMED",
	"RESYNC_REQUIRED",
	"NO_RS_BIND_ERROR",
	"RS_BIND_ERROR",
	"BACKUP_RECOVERED",
	"BACKUP_TOO_MANY_RETRIES",
	"BACKUP_TOO_MANY_HEAD_START_ATTEMPTS",
	"BACKUP_IN_UNEXPECTED_STATE",
	"TIMELY_SNAPSHOT",
	"LATE_SNAPSHOT",
	"TIMELY_WTC_SNAPSHOT",
	"LATE_WTC_SNAPSHOT",
	"CONSISTENT_BACKUP_CONFIGURATION",
	"INCONSISTENT_BACKUP_CONFIGURATION",
	"DAEMON_AVAILABLE_FOR_QUERYABLE_RESTORE_JOB",
	"NO_DAEMON_AVAILABLE_FOR_QUERYABLE_RESTORE_JOB",
	"GOOD_CLUSTERSHOT",
	"BAD_CLUSTERSHOTS",
	"SYNC_SLICE_PROGRESSED",
	"SYNC_SLICE_HAS_NOT_PROGRESSED",
	"BACKUP_JOB_NOT_BUSY",
	"BACKUP_JOB_TOO_BUSY",
	"BACKUP_NOT_LATE_TRACKING_JOB",
	"BACKUP_LATE_TRACKING_JOB",
	"BACKUP_NOT_LATE_INTEGRITY_CHECK_JOB",
	"BACKUP_LATE_INTEGRITY_CHECK_JOB",
	"BACKUP_NOT_LATE_GROOM_JOB",
	"BACKUP_LATE_GROOM_JOB",
	"BLOCKSTORE_JOB_RECOVERED",
	"BLOCKSTORE_JOB_TOO_MANY_RETRIES",
	"INITIAL_SYNC_STARTED_AUDIT",
	"INITIAL_SYNC_FINISHED_AUDIT",
	"RS_STATE_CHANGED_AUDIT",
	"CLUSTER_STATE_CHANGED_AUDIT",
	"RESTORE_REQUESTED_AUDIT",
	"INTERNAL_DIAGNOSTIC_RESTORE_REQUESTED_AUDIT",
	"SYNC_REQUIRED_AUDIT",
	"SYNC_PENDING_AUDIT",
	"CLUSTERSHOT_DELETED_AUDIT",
	"SNAPSHOT_DELETED_AUDIT",
	"RS_CREDENTIAL_UPDATED_AUDIT",
	"CLUSTER_CREDENTIAL_UPDATED_AUDIT",
	"RS_BLACKLIST_UPDATED_AUDIT",
	"CLUSTER_BLACKLIST_UPDATED_AUDIT",
	"RS_SNAPSHOT_SCHEDULE_UPDATED_AUDIT",
	"CLUSTER_SNAPSHOT_SCHEDULE_UPDATED_AUDIT",
	"CLUSTER_CHECKKPOINT_UPDATED_AUDIT",
	"RS_STORAGE_ENGINE_UPDATED_AUDIT",
	"CLUSTER_STORAGE_ENGINE_UPDATED_AUDIT",
	"RS_ROTATE_MASTER_KEY_AUDIT",
	"SNAPSHOT_EXPIRY_UPDATED_AUDIT",
	"CLUSTERSHOT_EXPIRY_UPDATED_AUDIT",
}

func (v *BackupEventType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := BackupEventType(value)
	for _, existing := range AllowedBackupEventTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid BackupEventType", value)
}

// NewBackupEventTypeFromValue returns a pointer to a valid BackupEventType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewBackupEventTypeFromValue(v string) (*BackupEventType, error) {
	ev := BackupEventType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for BackupEventType: valid values are %v", v, AllowedBackupEventTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v BackupEventType) IsValid() bool {
	for _, existing := range AllowedBackupEventTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to BackupEventType value
func (v BackupEventType) Ptr() *BackupEventType {
	return &v
}

type NullableBackupEventType struct {
	value *BackupEventType
	isSet bool
}

func (v NullableBackupEventType) Get() *BackupEventType {
	return v.value
}

func (v *NullableBackupEventType) Set(val *BackupEventType) {
	v.value = val
	v.isSet = true
}

func (v NullableBackupEventType) IsSet() bool {
	return v.isSet
}

func (v *NullableBackupEventType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBackupEventType(val *BackupEventType) *NullableBackupEventType {
	return &NullableBackupEventType{value: val, isSet: true}
}

func (v NullableBackupEventType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBackupEventType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

