/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type CloudBackupApi interface {

	/*
	RevokeAccessToAwsS3BucketForCloudBackupSnapshotExports Revoke Access to AWS S3 Bucket for Cloud Backup Snapshot Exports

	Revoke MongoDB Cloud access to the specified AWS S3 bucket. This prevents this bucket to receive Atlas Cloud Backup snapshots. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
	@param exportBucketId Unique string that identifies the AWS S3 bucket to which you export your snapshots.
	@return CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest
	*/
	RevokeAccessToAwsS3BucketForCloudBackupSnapshotExports(ctx context.Context, groupId string, exportBucketId string) CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest

	// RevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsExecute executes the request
	RevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsExecute(r CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest) (*http.Response, error)
}

// CloudBackupApiService CloudBackupApi service
type CloudBackupApiService service

type CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest struct {
	ctx context.Context
	ApiService CloudBackupApi
	groupId string
	exportBucketId string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest) Envelope(envelope bool) CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest {
	r.envelope = &envelope
	return r
}

func (r CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsExecute(r)
}

/*
RevokeAccessToAwsS3BucketForCloudBackupSnapshotExports Revoke Access to AWS S3 Bucket for Cloud Backup Snapshot Exports

Revoke MongoDB Cloud access to the specified AWS S3 bucket. This prevents this bucket to receive Atlas Cloud Backup snapshots. To use this resource, the requesting API Key must have the Project Atlas Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.
 @param exportBucketId Unique string that identifies the AWS S3 bucket to which you export your snapshots.
 @return CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest
*/
func (a *CloudBackupApiService) RevokeAccessToAwsS3BucketForCloudBackupSnapshotExports(ctx context.Context, groupId string, exportBucketId string) CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest {
	return CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		exportBucketId: exportBucketId,
	}
}

// Execute executes the request
func (a *CloudBackupApiService) RevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsExecute(r CloudBackupApiRevokeAccessToAwsS3BucketForCloudBackupSnapshotExportsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudBackupApiService.RevokeAccessToAwsS3BucketForCloudBackupSnapshotExports")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/backup/exportBuckets/{exportBucketId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"exportBucketId"+"}", url.PathEscape(parameterToString(r.exportBucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.exportBucketId) < 3 {
		return nil, reportError("exportBucketId must have at least 3 elements")
	}
	if strlen(r.exportBucketId) > 63 {
		return nil, reportError("exportBucketId must have less than 63 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
