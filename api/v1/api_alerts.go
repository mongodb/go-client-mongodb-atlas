/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type AlertsApi interface {

	/*
	AcknowledgeOneAlertFromOneProject Acknowledge One Alert from One Project

	Confirms receipt of one existing alert. This alert applies to any component in one project. Acknowledging an alert prevents successive notifications. You receive an alert when a monitored component meets or exceeds a value you set until you acknowledge the alert. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alerts-acknowledge-alert/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param alertId Unique 24-hexadecimal digit string that identifies the alert. Use the [/alerts](#tag/Alerts/operation/returnAllAlertsFromOneProject) endpoint to retrieve all alerts to which the authenticated user has access.
	@return AlertsApiAcknowledgeOneAlertFromOneProjectRequest
	*/
	AcknowledgeOneAlertFromOneProject(ctx context.Context, groupId string, alertId string) AlertsApiAcknowledgeOneAlertFromOneProjectRequest

	// AcknowledgeOneAlertFromOneProjectExecute executes the request
	//  @return AlertViewForGroup
	AcknowledgeOneAlertFromOneProjectExecute(r AlertsApiAcknowledgeOneAlertFromOneProjectRequest) (*AlertViewForGroup, *http.Response, error)

	/*
	ReturnAllAlertsFromOneProject Return All Alerts from One Project

	Returns all alerts. These alerts apply to all components in one project. You receive an alert when a monitored component meets or exceeds a value you set. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alerts-get-all-alerts/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return AlertsApiReturnAllAlertsFromOneProjectRequest
	*/
	ReturnAllAlertsFromOneProject(ctx context.Context, groupId string) AlertsApiReturnAllAlertsFromOneProjectRequest

	// ReturnAllAlertsFromOneProjectExecute executes the request
	//  @return PaginatedAlertView
	ReturnAllAlertsFromOneProjectExecute(r AlertsApiReturnAllAlertsFromOneProjectRequest) (*PaginatedAlertView, *http.Response, error)

	/*
	ReturnAllOpenAlertsForAlertConfiguration Return All Open Alerts for Alert Configuration

	Returns all open alerts that the specified alert configuration triggers. These alert configurations apply to the specified project only. Alert configurations define the triggers and notification methods for alerts. Open alerts have been triggered but remain unacknowledged. To use this resource, the requesting API Key must have the Project Read Only role.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-open-alerts/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param alertConfigId Unique 24-hexadecimal digit string that identifies the alert configuration. Use the [/alertConfigs](#tag/Alert-Configurations/operation/returnAllAlertConfigurationsForOneProject) endpoint to retrieve all alert configurations to which the authenticated user has access.
	@return AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest
	*/
	ReturnAllOpenAlertsForAlertConfiguration(ctx context.Context, groupId string, alertConfigId string) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest

	// ReturnAllOpenAlertsForAlertConfigurationExecute executes the request
	//  @return PaginatedAlertView
	ReturnAllOpenAlertsForAlertConfigurationExecute(r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) (*PaginatedAlertView, *http.Response, error)

	/*
	ReturnOneAlertFromOneProject Return One Alert from One Project

	Returns one alert. This alert applies to any component in one project. You receive an alert when a monitored component meets or exceeds a value you set. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alerts-get-alert/).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param alertId Unique 24-hexadecimal digit string that identifies the alert. Use the [/alerts](#tag/Alerts/operation/returnAllAlertsFromOneProject) endpoint to retrieve all alerts to which the authenticated user has access.
	@return AlertsApiReturnOneAlertFromOneProjectRequest
	*/
	ReturnOneAlertFromOneProject(ctx context.Context, groupId string, alertId string) AlertsApiReturnOneAlertFromOneProjectRequest

	// ReturnOneAlertFromOneProjectExecute executes the request
	//  @return AlertViewForGroup
	ReturnOneAlertFromOneProjectExecute(r AlertsApiReturnOneAlertFromOneProjectRequest) (*AlertViewForGroup, *http.Response, error)
}

// AlertsApiService AlertsApi service
type AlertsApiService service

type AlertsApiAcknowledgeOneAlertFromOneProjectRequest struct {
	ctx context.Context
	ApiService AlertsApi
	groupId string
	alertId string
	alertViewForGroup *AlertViewForGroup
	envelope *bool
	pretty *bool
}

// Confirm one alert.
func (r AlertsApiAcknowledgeOneAlertFromOneProjectRequest) AlertViewForGroup(alertViewForGroup AlertViewForGroup) AlertsApiAcknowledgeOneAlertFromOneProjectRequest {
	r.alertViewForGroup = &alertViewForGroup
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r AlertsApiAcknowledgeOneAlertFromOneProjectRequest) Envelope(envelope bool) AlertsApiAcknowledgeOneAlertFromOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r AlertsApiAcknowledgeOneAlertFromOneProjectRequest) Pretty(pretty bool) AlertsApiAcknowledgeOneAlertFromOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r AlertsApiAcknowledgeOneAlertFromOneProjectRequest) Execute() (*AlertViewForGroup, *http.Response, error) {
	return r.ApiService.AcknowledgeOneAlertFromOneProjectExecute(r)
}

/*
AcknowledgeOneAlertFromOneProject Acknowledge One Alert from One Project

Confirms receipt of one existing alert. This alert applies to any component in one project. Acknowledging an alert prevents successive notifications. You receive an alert when a monitored component meets or exceeds a value you set until you acknowledge the alert. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alerts-acknowledge-alert/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param alertId Unique 24-hexadecimal digit string that identifies the alert. Use the [/alerts](#tag/Alerts/operation/returnAllAlertsFromOneProject) endpoint to retrieve all alerts to which the authenticated user has access.
 @return AlertsApiAcknowledgeOneAlertFromOneProjectRequest
*/
func (a *AlertsApiService) AcknowledgeOneAlertFromOneProject(ctx context.Context, groupId string, alertId string) AlertsApiAcknowledgeOneAlertFromOneProjectRequest {
	return AlertsApiAcknowledgeOneAlertFromOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		alertId: alertId,
	}
}

// Execute executes the request
//  @return AlertViewForGroup
func (a *AlertsApiService) AcknowledgeOneAlertFromOneProjectExecute(r AlertsApiAcknowledgeOneAlertFromOneProjectRequest) (*AlertViewForGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertViewForGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.AcknowledgeOneAlertFromOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/alerts/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterToString(r.alertId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.alertId) < 24 {
		return localVarReturnValue, nil, reportError("alertId must have at least 24 elements")
	}
	if strlen(r.alertId) > 24 {
		return localVarReturnValue, nil, reportError("alertId must have less than 24 elements")
	}
	if r.alertViewForGroup == nil {
		return localVarReturnValue, nil, reportError("alertViewForGroup is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alertViewForGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiReturnAllAlertsFromOneProjectRequest struct {
	ctx context.Context
	ApiService AlertsApi
	groupId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r AlertsApiReturnAllAlertsFromOneProjectRequest) Envelope(envelope bool) AlertsApiReturnAllAlertsFromOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r AlertsApiReturnAllAlertsFromOneProjectRequest) IncludeCount(includeCount bool) AlertsApiReturnAllAlertsFromOneProjectRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r AlertsApiReturnAllAlertsFromOneProjectRequest) ItemsPerPage(itemsPerPage int32) AlertsApiReturnAllAlertsFromOneProjectRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r AlertsApiReturnAllAlertsFromOneProjectRequest) PageNum(pageNum int32) AlertsApiReturnAllAlertsFromOneProjectRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r AlertsApiReturnAllAlertsFromOneProjectRequest) Pretty(pretty bool) AlertsApiReturnAllAlertsFromOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r AlertsApiReturnAllAlertsFromOneProjectRequest) Execute() (*PaginatedAlertView, *http.Response, error) {
	return r.ApiService.ReturnAllAlertsFromOneProjectExecute(r)
}

/*
ReturnAllAlertsFromOneProject Return All Alerts from One Project

Returns all alerts. These alerts apply to all components in one project. You receive an alert when a monitored component meets or exceeds a value you set. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alerts-get-all-alerts/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return AlertsApiReturnAllAlertsFromOneProjectRequest
*/
func (a *AlertsApiService) ReturnAllAlertsFromOneProject(ctx context.Context, groupId string) AlertsApiReturnAllAlertsFromOneProjectRequest {
	return AlertsApiReturnAllAlertsFromOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return PaginatedAlertView
func (a *AlertsApiService) ReturnAllAlertsFromOneProjectExecute(r AlertsApiReturnAllAlertsFromOneProjectRequest) (*PaginatedAlertView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAlertView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.ReturnAllAlertsFromOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest struct {
	ctx context.Context
	ApiService AlertsApi
	groupId string
	alertConfigId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) Envelope(envelope bool) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) IncludeCount(includeCount bool) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) ItemsPerPage(itemsPerPage int32) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) PageNum(pageNum int32) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) Pretty(pretty bool) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest {
	r.pretty = &pretty
	return r
}

func (r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) Execute() (*PaginatedAlertView, *http.Response, error) {
	return r.ApiService.ReturnAllOpenAlertsForAlertConfigurationExecute(r)
}

/*
ReturnAllOpenAlertsForAlertConfiguration Return All Open Alerts for Alert Configuration

Returns all open alerts that the specified alert configuration triggers. These alert configurations apply to the specified project only. Alert configurations define the triggers and notification methods for alerts. Open alerts have been triggered but remain unacknowledged. To use this resource, the requesting API Key must have the Project Read Only role.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-open-alerts/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param alertConfigId Unique 24-hexadecimal digit string that identifies the alert configuration. Use the [/alertConfigs](#tag/Alert-Configurations/operation/returnAllAlertConfigurationsForOneProject) endpoint to retrieve all alert configurations to which the authenticated user has access.
 @return AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest
*/
func (a *AlertsApiService) ReturnAllOpenAlertsForAlertConfiguration(ctx context.Context, groupId string, alertConfigId string) AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest {
	return AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		alertConfigId: alertConfigId,
	}
}

// Execute executes the request
//  @return PaginatedAlertView
func (a *AlertsApiService) ReturnAllOpenAlertsForAlertConfigurationExecute(r AlertsApiReturnAllOpenAlertsForAlertConfigurationRequest) (*PaginatedAlertView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAlertView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.ReturnAllOpenAlertsForAlertConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/alerts/{alertConfigId}/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertConfigId"+"}", url.PathEscape(parameterToString(r.alertConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.alertConfigId) < 24 {
		return localVarReturnValue, nil, reportError("alertConfigId must have at least 24 elements")
	}
	if strlen(r.alertConfigId) > 24 {
		return localVarReturnValue, nil, reportError("alertConfigId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiReturnOneAlertFromOneProjectRequest struct {
	ctx context.Context
	ApiService AlertsApi
	groupId string
	alertId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r AlertsApiReturnOneAlertFromOneProjectRequest) Envelope(envelope bool) AlertsApiReturnOneAlertFromOneProjectRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r AlertsApiReturnOneAlertFromOneProjectRequest) Pretty(pretty bool) AlertsApiReturnOneAlertFromOneProjectRequest {
	r.pretty = &pretty
	return r
}

func (r AlertsApiReturnOneAlertFromOneProjectRequest) Execute() (*AlertViewForGroup, *http.Response, error) {
	return r.ApiService.ReturnOneAlertFromOneProjectExecute(r)
}

/*
ReturnOneAlertFromOneProject Return One Alert from One Project

Returns one alert. This alert applies to any component in one project. You receive an alert when a monitored component meets or exceeds a value you set. To use this resource, the requesting API Key must have the Project Read Only role. This resource doesn't require the API Key to have an Access List.

 This resource remains under revision and may change. Refer to the [legacy documentation for this resource](https://www.mongodb.com/docs/atlas/reference/api/alerts-get-alert/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param alertId Unique 24-hexadecimal digit string that identifies the alert. Use the [/alerts](#tag/Alerts/operation/returnAllAlertsFromOneProject) endpoint to retrieve all alerts to which the authenticated user has access.
 @return AlertsApiReturnOneAlertFromOneProjectRequest
*/
func (a *AlertsApiService) ReturnOneAlertFromOneProject(ctx context.Context, groupId string, alertId string) AlertsApiReturnOneAlertFromOneProjectRequest {
	return AlertsApiReturnOneAlertFromOneProjectRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		alertId: alertId,
	}
}

// Execute executes the request
//  @return AlertViewForGroup
func (a *AlertsApiService) ReturnOneAlertFromOneProjectExecute(r AlertsApiReturnOneAlertFromOneProjectRequest) (*AlertViewForGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertViewForGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.ReturnOneAlertFromOneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/alerts/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterToString(r.alertId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.alertId) < 24 {
		return localVarReturnValue, nil, reportError("alertId must have at least 24 elements")
	}
	if strlen(r.alertId) > 24 {
		return localVarReturnValue, nil, reportError("alertId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
