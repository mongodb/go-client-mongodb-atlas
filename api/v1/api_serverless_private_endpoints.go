/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type ServerlessPrivateEndpointsApi interface {

	/*
	CreateOnePrivateEndpointForOneServerlessInstance Create One Private Endpoint for One Serverless Instance

	Creates one private endpoint for one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 A new endpoint won't be immediately available after creation.  Read the steps in the linked tutorial for detailed guidance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param instanceName Human-readable label that identifies the serverless instance for which the tenant endpoint will be created.
	@return ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest
	*/
	CreateOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string) ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest

	// CreateOnePrivateEndpointForOneServerlessInstanceExecute executes the request
	//  @return ServerlessTenantEndpoint
	CreateOnePrivateEndpointForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) (*ServerlessTenantEndpoint, *http.Response, error)

	/*
	RemoveOnePrivateEndpointFromOneServerlessInstance Remove One Private Endpoint for One Serverless Instance

	Remove one private endpoint from one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param instanceName Human-readable label that identifies the serverless instance from which the tenant endpoint will be removed.
	@param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint which will be removed.
	@return ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest
	*/
	RemoveOnePrivateEndpointFromOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest

	// RemoveOnePrivateEndpointFromOneServerlessInstanceExecute executes the request
	RemoveOnePrivateEndpointFromOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) (*http.Response, error)

	/*
	ReturnAllPrivateEndpointsForOneServerlessInstance Return All Private Endpoints for One Serverless Instance

	Returns all private endpoints for one serverless instance. You must have at least the Project Read Only role for the project to successfully call this resource. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint.
	@return ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest
	*/
	ReturnAllPrivateEndpointsForOneServerlessInstance(ctx context.Context, groupId string, instanceName string) ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest

	// ReturnAllPrivateEndpointsForOneServerlessInstanceExecute executes the request
	//  @return []ServerlessTenantEndpoint
	ReturnAllPrivateEndpointsForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) ([]ServerlessTenantEndpoint, *http.Response, error)

	/*
	ReturnOnePrivateEndpointForOneServerlessInstance Return One Private Endpoint for One Serverless Instance

	Return one private endpoint for one serverless instance. Identify this endpoint using its unique ID. You must have at least the Project Read Only role for the project to successfully call this resource. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint.
	@param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint.
	@return ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest
	*/
	ReturnOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest

	// ReturnOnePrivateEndpointForOneServerlessInstanceExecute executes the request
	//  @return ServerlessTenantEndpoint
	ReturnOnePrivateEndpointForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) (*ServerlessTenantEndpoint, *http.Response, error)

	/*
	UpdateOnePrivateEndpointForOneServerlessInstance Update One Private Endpoint for One Serverless Instance

	Updates one private endpoint for one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint that will be updated.
	@param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint which will be updated.
	@return ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest
	*/
	UpdateOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest

	// UpdateOnePrivateEndpointForOneServerlessInstanceExecute executes the request
	//  @return ServerlessTenantEndpoint
	UpdateOnePrivateEndpointForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) (*ServerlessTenantEndpoint, *http.Response, error)
}

// ServerlessPrivateEndpointsApiService ServerlessPrivateEndpointsApi service
type ServerlessPrivateEndpointsApiService service

type ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService ServerlessPrivateEndpointsApi
	groupId string
	instanceName string
	envelope *bool
	serverlessTenantEndpointCreate *ServerlessTenantEndpointCreate
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) Envelope(envelope bool) ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) ServerlessTenantEndpointCreate(serverlessTenantEndpointCreate ServerlessTenantEndpointCreate) ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.serverlessTenantEndpointCreate = &serverlessTenantEndpointCreate
	return r
}

func (r ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) Execute() (*ServerlessTenantEndpoint, *http.Response, error) {
	return r.ApiService.CreateOnePrivateEndpointForOneServerlessInstanceExecute(r)
}

/*
CreateOnePrivateEndpointForOneServerlessInstance Create One Private Endpoint for One Serverless Instance

Creates one private endpoint for one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 A new endpoint won't be immediately available after creation.  Read the steps in the linked tutorial for detailed guidance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance for which the tenant endpoint will be created.
 @return ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) CreateOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string) ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest {
	return ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
	}
}

// Execute executes the request
//  @return ServerlessTenantEndpoint
func (a *ServerlessPrivateEndpointsApiService) CreateOnePrivateEndpointForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) (*ServerlessTenantEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerlessTenantEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.CreateOnePrivateEndpointForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serverlessTenantEndpointCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService ServerlessPrivateEndpointsApi
	groupId string
	instanceName string
	endpointId string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) Envelope(envelope bool) ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOnePrivateEndpointFromOneServerlessInstanceExecute(r)
}

/*
RemoveOnePrivateEndpointFromOneServerlessInstance Remove One Private Endpoint for One Serverless Instance

Remove one private endpoint from one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance from which the tenant endpoint will be removed.
 @param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint which will be removed.
 @return ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) RemoveOnePrivateEndpointFromOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest {
	return ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
		endpointId: endpointId,
	}
}

// Execute executes the request
func (a *ServerlessPrivateEndpointsApiService) RemoveOnePrivateEndpointFromOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.RemoveOnePrivateEndpointFromOneServerlessInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return nil, reportError("instanceName must have less than 64 elements")
	}
	if strlen(r.endpointId) < 24 {
		return nil, reportError("endpointId must have at least 24 elements")
	}
	if strlen(r.endpointId) > 24 {
		return nil, reportError("endpointId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService ServerlessPrivateEndpointsApi
	groupId string
	instanceName string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) Envelope(envelope bool) ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) Execute() ([]ServerlessTenantEndpoint, *http.Response, error) {
	return r.ApiService.ReturnAllPrivateEndpointsForOneServerlessInstanceExecute(r)
}

/*
ReturnAllPrivateEndpointsForOneServerlessInstance Return All Private Endpoints for One Serverless Instance

Returns all private endpoints for one serverless instance. You must have at least the Project Read Only role for the project to successfully call this resource. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint.
 @return ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) ReturnAllPrivateEndpointsForOneServerlessInstance(ctx context.Context, groupId string, instanceName string) ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest {
	return ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
	}
}

// Execute executes the request
//  @return []ServerlessTenantEndpoint
func (a *ServerlessPrivateEndpointsApiService) ReturnAllPrivateEndpointsForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) ([]ServerlessTenantEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServerlessTenantEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.ReturnAllPrivateEndpointsForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService ServerlessPrivateEndpointsApi
	groupId string
	instanceName string
	endpointId string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) Envelope(envelope bool) ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) Execute() (*ServerlessTenantEndpoint, *http.Response, error) {
	return r.ApiService.ReturnOnePrivateEndpointForOneServerlessInstanceExecute(r)
}

/*
ReturnOnePrivateEndpointForOneServerlessInstance Return One Private Endpoint for One Serverless Instance

Return one private endpoint for one serverless instance. Identify this endpoint using its unique ID. You must have at least the Project Read Only role for the project to successfully call this resource. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint.
 @param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint.
 @return ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) ReturnOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest {
	return ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return ServerlessTenantEndpoint
func (a *ServerlessPrivateEndpointsApiService) ReturnOnePrivateEndpointForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) (*ServerlessTenantEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerlessTenantEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.ReturnOnePrivateEndpointForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}
	if strlen(r.endpointId) < 24 {
		return localVarReturnValue, nil, reportError("endpointId must have at least 24 elements")
	}
	if strlen(r.endpointId) > 24 {
		return localVarReturnValue, nil, reportError("endpointId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService ServerlessPrivateEndpointsApi
	groupId string
	instanceName string
	endpointId string
	envelope *bool
	serverlessTenantEndpointUpdate *ServerlessTenantEndpointUpdate
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) Envelope(envelope bool) ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) ServerlessTenantEndpointUpdate(serverlessTenantEndpointUpdate ServerlessTenantEndpointUpdate) ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.serverlessTenantEndpointUpdate = &serverlessTenantEndpointUpdate
	return r
}

func (r ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) Execute() (*ServerlessTenantEndpoint, *http.Response, error) {
	return r.ApiService.UpdateOnePrivateEndpointForOneServerlessInstanceExecute(r)
}

/*
UpdateOnePrivateEndpointForOneServerlessInstance Update One Private Endpoint for One Serverless Instance

Updates one private endpoint for one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint that will be updated.
 @param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint which will be updated.
 @return ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) UpdateOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest {
	return ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return ServerlessTenantEndpoint
func (a *ServerlessPrivateEndpointsApiService) UpdateOnePrivateEndpointForOneServerlessInstanceExecute(r ServerlessPrivateEndpointsApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) (*ServerlessTenantEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerlessTenantEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.UpdateOnePrivateEndpointForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}
	if strlen(r.endpointId) < 24 {
		return localVarReturnValue, nil, reportError("endpointId must have at least 24 elements")
	}
	if strlen(r.endpointId) > 24 {
		return localVarReturnValue, nil, reportError("endpointId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serverlessTenantEndpointUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
