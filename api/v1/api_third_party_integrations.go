/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type ThirdPartyIntegrationsApi interface {

	/*
	ConfigureOneThirdPartyServiceIntegration Configure One Third-Party Service Integration

	Adds the settings for configuring one third-party service integration. These settings apply to all databases managed in the specified MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest
	*/
	ConfigureOneThirdPartyServiceIntegration(ctx context.Context, integrationType string, groupId string) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest

	// ConfigureOneThirdPartyServiceIntegrationExecute executes the request
	//  @return PaginatedIntegrationView
	ConfigureOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) (*PaginatedIntegrationView, *http.Response, error)

	/*
	RemoveOneThirdPartyServiceIntegration Remove One Third-Party Service Integration

	Removes the settings that permit configuring one third-party service integration. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest
	*/
	RemoveOneThirdPartyServiceIntegration(ctx context.Context, integrationType string, groupId string) ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest

	// RemoveOneThirdPartyServiceIntegrationExecute executes the request
	RemoveOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest) (*http.Response, error)

	/*
	ReturnAllActiveThirdPartyServiceIntegrations Return All Active Third-Party Service Integrations

	Returns the settings that permit integrations with all configured third-party services. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest
	*/
	ReturnAllActiveThirdPartyServiceIntegrations(ctx context.Context, groupId string) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest

	// ReturnAllActiveThirdPartyServiceIntegrationsExecute executes the request
	//  @return PaginatedIntegrationView
	ReturnAllActiveThirdPartyServiceIntegrationsExecute(r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) (*PaginatedIntegrationView, *http.Response, error)

	/*
	ReturnOneThirdPartyServiceIntegration Return One Third-Party Service Integration

	Returns the settings for configuring integration with one third-party service. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
	@return ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest
	*/
	ReturnOneThirdPartyServiceIntegration(ctx context.Context, groupId string, integrationType string) ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest

	// ReturnOneThirdPartyServiceIntegrationExecute executes the request
	//  @return ApiIntegrationViewManual
	ReturnOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest) (*ApiIntegrationViewManual, *http.Response, error)

	/*
	UpdateOneThirdPartyServiceIntegration Update One Third-Party Service Integration

	Updates the settings for configuring integration with one third-party service. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
	@param groupId Unique 24-hexadecimal digit string that identifies your project.
	@return ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest
	*/
	UpdateOneThirdPartyServiceIntegration(ctx context.Context, integrationType string, groupId string) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest

	// UpdateOneThirdPartyServiceIntegrationExecute executes the request
	//  @return PaginatedIntegrationView
	UpdateOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) (*PaginatedIntegrationView, *http.Response, error)
}

// ThirdPartyIntegrationsApiService ThirdPartyIntegrationsApi service
type ThirdPartyIntegrationsApiService service

type ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest struct {
	ctx context.Context
	ApiService ThirdPartyIntegrationsApi
	integrationType string
	groupId string
	apiIntegrationViewManual *ApiIntegrationViewManual
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Third-party integration configuration that you want to configure for your project.
func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) ApiIntegrationViewManual(apiIntegrationViewManual ApiIntegrationViewManual) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	r.apiIntegrationViewManual = &apiIntegrationViewManual
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) Envelope(envelope bool) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) IncludeCount(includeCount bool) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) ItemsPerPage(itemsPerPage int32) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) PageNum(pageNum int32) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) Pretty(pretty bool) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	r.pretty = &pretty
	return r
}

func (r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) Execute() (*PaginatedIntegrationView, *http.Response, error) {
	return r.ApiService.ConfigureOneThirdPartyServiceIntegrationExecute(r)
}

/*
ConfigureOneThirdPartyServiceIntegration Configure One Third-Party Service Integration

Adds the settings for configuring one third-party service integration. These settings apply to all databases managed in the specified MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest
*/
func (a *ThirdPartyIntegrationsApiService) ConfigureOneThirdPartyServiceIntegration(ctx context.Context, integrationType string, groupId string) ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest {
	return ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		integrationType: integrationType,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationView
func (a *ThirdPartyIntegrationsApiService) ConfigureOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiConfigureOneThirdPartyServiceIntegrationRequest) (*PaginatedIntegrationView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIntegrationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyIntegrationsApiService.ConfigureOneThirdPartyServiceIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/integrations/{integrationType}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationType"+"}", url.PathEscape(parameterToString(r.integrationType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if r.apiIntegrationViewManual == nil {
		return localVarReturnValue, nil, reportError("apiIntegrationViewManual is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiIntegrationViewManual
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest struct {
	ctx context.Context
	ApiService ThirdPartyIntegrationsApi
	integrationType string
	groupId string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest) Envelope(envelope bool) ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest) Pretty(pretty bool) ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest {
	r.pretty = &pretty
	return r
}

func (r ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOneThirdPartyServiceIntegrationExecute(r)
}

/*
RemoveOneThirdPartyServiceIntegration Remove One Third-Party Service Integration

Removes the settings that permit configuring one third-party service integration. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest
*/
func (a *ThirdPartyIntegrationsApiService) RemoveOneThirdPartyServiceIntegration(ctx context.Context, integrationType string, groupId string) ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest {
	return ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		integrationType: integrationType,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *ThirdPartyIntegrationsApiService) RemoveOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiRemoveOneThirdPartyServiceIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyIntegrationsApiService.RemoveOneThirdPartyServiceIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/integrations/{integrationType}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationType"+"}", url.PathEscape(parameterToString(r.integrationType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest struct {
	ctx context.Context
	ApiService ThirdPartyIntegrationsApi
	groupId string
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) Envelope(envelope bool) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) IncludeCount(includeCount bool) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) ItemsPerPage(itemsPerPage int32) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) PageNum(pageNum int32) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) Pretty(pretty bool) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest {
	r.pretty = &pretty
	return r
}

func (r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) Execute() (*PaginatedIntegrationView, *http.Response, error) {
	return r.ApiService.ReturnAllActiveThirdPartyServiceIntegrationsExecute(r)
}

/*
ReturnAllActiveThirdPartyServiceIntegrations Return All Active Third-Party Service Integrations

Returns the settings that permit integrations with all configured third-party services. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest
*/
func (a *ThirdPartyIntegrationsApiService) ReturnAllActiveThirdPartyServiceIntegrations(ctx context.Context, groupId string) ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest {
	return ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationView
func (a *ThirdPartyIntegrationsApiService) ReturnAllActiveThirdPartyServiceIntegrationsExecute(r ThirdPartyIntegrationsApiReturnAllActiveThirdPartyServiceIntegrationsRequest) (*PaginatedIntegrationView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIntegrationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyIntegrationsApiService.ReturnAllActiveThirdPartyServiceIntegrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/integrations"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest struct {
	ctx context.Context
	ApiService ThirdPartyIntegrationsApi
	groupId string
	integrationType string
	envelope *bool
	pretty *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest) Envelope(envelope bool) ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest) Pretty(pretty bool) ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest {
	r.pretty = &pretty
	return r
}

func (r ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest) Execute() (*ApiIntegrationViewManual, *http.Response, error) {
	return r.ApiService.ReturnOneThirdPartyServiceIntegrationExecute(r)
}

/*
ReturnOneThirdPartyServiceIntegration Return One Third-Party Service Integration

Returns the settings for configuring integration with one third-party service. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
 @return ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest
*/
func (a *ThirdPartyIntegrationsApiService) ReturnOneThirdPartyServiceIntegration(ctx context.Context, groupId string, integrationType string) ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest {
	return ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		integrationType: integrationType,
	}
}

// Execute executes the request
//  @return ApiIntegrationViewManual
func (a *ThirdPartyIntegrationsApiService) ReturnOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiReturnOneThirdPartyServiceIntegrationRequest) (*ApiIntegrationViewManual, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiIntegrationViewManual
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyIntegrationsApiService.ReturnOneThirdPartyServiceIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/integrations/{integrationType}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationType"+"}", url.PathEscape(parameterToString(r.integrationType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest struct {
	ctx context.Context
	ApiService ThirdPartyIntegrationsApi
	integrationType string
	groupId string
	apiIntegrationViewManual *ApiIntegrationViewManual
	envelope *bool
	includeCount *bool
	itemsPerPage *int32
	pageNum *int32
	pretty *bool
}

// Third-party integration configuration that you want to configure for your project.
func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) ApiIntegrationViewManual(apiIntegrationViewManual ApiIntegrationViewManual) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	r.apiIntegrationViewManual = &apiIntegrationViewManual
	return r
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) Envelope(envelope bool) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	r.envelope = &envelope
	return r
}

// Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.
func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) IncludeCount(includeCount bool) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	r.includeCount = &includeCount
	return r
}

// Number of items that the response returns per page.
func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) ItemsPerPage(itemsPerPage int32) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// Number of the page that displays the current set of the total objects that the response returns.
func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) PageNum(pageNum int32) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	r.pageNum = &pageNum
	return r
}

// Flag that indicates whether the response body should be in the prettyprint format.
func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) Pretty(pretty bool) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	r.pretty = &pretty
	return r
}

func (r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) Execute() (*PaginatedIntegrationView, *http.Response, error) {
	return r.ApiService.UpdateOneThirdPartyServiceIntegrationExecute(r)
}

/*
UpdateOneThirdPartyServiceIntegration Update One Third-Party Service Integration

Updates the settings for configuring integration with one third-party service. These settings apply to all databases managed in one MongoDB Cloud project. To use this resource, the requesting API Key must have the Project Monitoring Admin role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationType Human-readable label that identifies the service which you want to integrate with MongoDB Cloud.
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @return ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest
*/
func (a *ThirdPartyIntegrationsApiService) UpdateOneThirdPartyServiceIntegration(ctx context.Context, integrationType string, groupId string) ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest {
	return ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		integrationType: integrationType,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationView
func (a *ThirdPartyIntegrationsApiService) UpdateOneThirdPartyServiceIntegrationExecute(r ThirdPartyIntegrationsApiUpdateOneThirdPartyServiceIntegrationRequest) (*PaginatedIntegrationView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIntegrationView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyIntegrationsApiService.UpdateOneThirdPartyServiceIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v2/groups/{groupId}/integrations/{integrationType}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationType"+"}", url.PathEscape(parameterToString(r.integrationType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if r.apiIntegrationViewManual == nil {
		return localVarReturnValue, nil, reportError("apiIntegrationViewManual is required and must be specified")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	if r.includeCount != nil {
		localVarQueryParams.Add("includeCount", parameterToString(*r.includeCount, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.pageNum != nil {
		localVarQueryParams.Add("pageNum", parameterToString(*r.pageNum, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.atlas.2023-01-01+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiIntegrationViewManual
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
