/*
API version: 2.0~61723fd7f1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mongodbatlasv2

import (
	"encoding/json"
	"fmt"
)

// Integration - Collection of settings that describe third-party integrations.
type Integration struct {
	Datadog *Datadog
	MicrosoftTeams *MicrosoftTeams
	NewRelic *NewRelic
	OpsGenie *OpsGenie
	PagerDuty *PagerDuty
	Prometheus *Prometheus
	Slack *Slack
	VictorOps *VictorOps
	Webhook *Webhook
}

// DatadogAsIntegration is a convenience function that returns Datadog wrapped in Integration
func DatadogAsIntegration(v *Datadog) Integration {
	return Integration{
		Datadog: v,
	}
}

// MicrosoftTeamsAsIntegration is a convenience function that returns MicrosoftTeams wrapped in Integration
func MicrosoftTeamsAsIntegration(v *MicrosoftTeams) Integration {
	return Integration{
		MicrosoftTeams: v,
	}
}

// NewRelicAsIntegration is a convenience function that returns NewRelic wrapped in Integration
func NewRelicAsIntegration(v *NewRelic) Integration {
	return Integration{
		NewRelic: v,
	}
}

// OpsGenieAsIntegration is a convenience function that returns OpsGenie wrapped in Integration
func OpsGenieAsIntegration(v *OpsGenie) Integration {
	return Integration{
		OpsGenie: v,
	}
}

// PagerDutyAsIntegration is a convenience function that returns PagerDuty wrapped in Integration
func PagerDutyAsIntegration(v *PagerDuty) Integration {
	return Integration{
		PagerDuty: v,
	}
}

// PrometheusAsIntegration is a convenience function that returns Prometheus wrapped in Integration
func PrometheusAsIntegration(v *Prometheus) Integration {
	return Integration{
		Prometheus: v,
	}
}

// SlackAsIntegration is a convenience function that returns Slack wrapped in Integration
func SlackAsIntegration(v *Slack) Integration {
	return Integration{
		Slack: v,
	}
}

// VictorOpsAsIntegration is a convenience function that returns VictorOps wrapped in Integration
func VictorOpsAsIntegration(v *VictorOps) Integration {
	return Integration{
		VictorOps: v,
	}
}

// WebhookAsIntegration is a convenience function that returns Webhook wrapped in Integration
func WebhookAsIntegration(v *Webhook) Integration {
	return Integration{
		Webhook: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *Integration) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = newStrictDecoder(data).Decode(&jsonDict)
	if err != nil {
		return fmt.Errorf("failed to unmarshal JSON into map for the discriminator lookup")
	}

	// check if the discriminator value is 'DATADOG'
	if jsonDict["type"] == "DATADOG" {
		// try to unmarshal JSON data into Datadog
		err = json.Unmarshal(data, &dst.Datadog)
		if err == nil {
			return nil // data stored in dst.Datadog, return on the first match
		} else {
			dst.Datadog = nil
			return fmt.Errorf("failed to unmarshal Integration as Datadog: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Datadog'
	if jsonDict["type"] == "Datadog" {
		// try to unmarshal JSON data into Datadog
		err = json.Unmarshal(data, &dst.Datadog)
		if err == nil {
			return nil // data stored in dst.Datadog, return on the first match
		} else {
			dst.Datadog = nil
			return fmt.Errorf("failed to unmarshal Integration as Datadog: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MICROSOFT_TEAMS'
	if jsonDict["type"] == "MICROSOFT_TEAMS" {
		// try to unmarshal JSON data into MicrosoftTeams
		err = json.Unmarshal(data, &dst.MicrosoftTeams)
		if err == nil {
			return nil // data stored in dst.MicrosoftTeams, return on the first match
		} else {
			dst.MicrosoftTeams = nil
			return fmt.Errorf("failed to unmarshal Integration as MicrosoftTeams: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MicrosoftTeams'
	if jsonDict["type"] == "MicrosoftTeams" {
		// try to unmarshal JSON data into MicrosoftTeams
		err = json.Unmarshal(data, &dst.MicrosoftTeams)
		if err == nil {
			return nil // data stored in dst.MicrosoftTeams, return on the first match
		} else {
			dst.MicrosoftTeams = nil
			return fmt.Errorf("failed to unmarshal Integration as MicrosoftTeams: %s", err.Error())
		}
	}

	// check if the discriminator value is 'NEW_RELIC'
	if jsonDict["type"] == "NEW_RELIC" {
		// try to unmarshal JSON data into NewRelic
		err = json.Unmarshal(data, &dst.NewRelic)
		if err == nil {
			return nil // data stored in dst.NewRelic, return on the first match
		} else {
			dst.NewRelic = nil
			return fmt.Errorf("failed to unmarshal Integration as NewRelic: %s", err.Error())
		}
	}

	// check if the discriminator value is 'NewRelic'
	if jsonDict["type"] == "NewRelic" {
		// try to unmarshal JSON data into NewRelic
		err = json.Unmarshal(data, &dst.NewRelic)
		if err == nil {
			return nil // data stored in dst.NewRelic, return on the first match
		} else {
			dst.NewRelic = nil
			return fmt.Errorf("failed to unmarshal Integration as NewRelic: %s", err.Error())
		}
	}

	// check if the discriminator value is 'OPS_GENIE'
	if jsonDict["type"] == "OPS_GENIE" {
		// try to unmarshal JSON data into OpsGenie
		err = json.Unmarshal(data, &dst.OpsGenie)
		if err == nil {
			return nil // data stored in dst.OpsGenie, return on the first match
		} else {
			dst.OpsGenie = nil
			return fmt.Errorf("failed to unmarshal Integration as OpsGenie: %s", err.Error())
		}
	}

	// check if the discriminator value is 'OpsGenie'
	if jsonDict["type"] == "OpsGenie" {
		// try to unmarshal JSON data into OpsGenie
		err = json.Unmarshal(data, &dst.OpsGenie)
		if err == nil {
			return nil // data stored in dst.OpsGenie, return on the first match
		} else {
			dst.OpsGenie = nil
			return fmt.Errorf("failed to unmarshal Integration as OpsGenie: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PAGER_DUTY'
	if jsonDict["type"] == "PAGER_DUTY" {
		// try to unmarshal JSON data into PagerDuty
		err = json.Unmarshal(data, &dst.PagerDuty)
		if err == nil {
			return nil // data stored in dst.PagerDuty, return on the first match
		} else {
			dst.PagerDuty = nil
			return fmt.Errorf("failed to unmarshal Integration as PagerDuty: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PROMETHEUS'
	if jsonDict["type"] == "PROMETHEUS" {
		// try to unmarshal JSON data into Prometheus
		err = json.Unmarshal(data, &dst.Prometheus)
		if err == nil {
			return nil // data stored in dst.Prometheus, return on the first match
		} else {
			dst.Prometheus = nil
			return fmt.Errorf("failed to unmarshal Integration as Prometheus: %s", err.Error())
		}
	}

	// check if the discriminator value is 'PagerDuty'
	if jsonDict["type"] == "PagerDuty" {
		// try to unmarshal JSON data into PagerDuty
		err = json.Unmarshal(data, &dst.PagerDuty)
		if err == nil {
			return nil // data stored in dst.PagerDuty, return on the first match
		} else {
			dst.PagerDuty = nil
			return fmt.Errorf("failed to unmarshal Integration as PagerDuty: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Prometheus'
	if jsonDict["type"] == "Prometheus" {
		// try to unmarshal JSON data into Prometheus
		err = json.Unmarshal(data, &dst.Prometheus)
		if err == nil {
			return nil // data stored in dst.Prometheus, return on the first match
		} else {
			dst.Prometheus = nil
			return fmt.Errorf("failed to unmarshal Integration as Prometheus: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SLACK'
	if jsonDict["type"] == "SLACK" {
		// try to unmarshal JSON data into Slack
		err = json.Unmarshal(data, &dst.Slack)
		if err == nil {
			return nil // data stored in dst.Slack, return on the first match
		} else {
			dst.Slack = nil
			return fmt.Errorf("failed to unmarshal Integration as Slack: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Slack'
	if jsonDict["type"] == "Slack" {
		// try to unmarshal JSON data into Slack
		err = json.Unmarshal(data, &dst.Slack)
		if err == nil {
			return nil // data stored in dst.Slack, return on the first match
		} else {
			dst.Slack = nil
			return fmt.Errorf("failed to unmarshal Integration as Slack: %s", err.Error())
		}
	}

	// check if the discriminator value is 'VICTOR_OPS'
	if jsonDict["type"] == "VICTOR_OPS" {
		// try to unmarshal JSON data into VictorOps
		err = json.Unmarshal(data, &dst.VictorOps)
		if err == nil {
			return nil // data stored in dst.VictorOps, return on the first match
		} else {
			dst.VictorOps = nil
			return fmt.Errorf("failed to unmarshal Integration as VictorOps: %s", err.Error())
		}
	}

	// check if the discriminator value is 'VictorOps'
	if jsonDict["type"] == "VictorOps" {
		// try to unmarshal JSON data into VictorOps
		err = json.Unmarshal(data, &dst.VictorOps)
		if err == nil {
			return nil // data stored in dst.VictorOps, return on the first match
		} else {
			dst.VictorOps = nil
			return fmt.Errorf("failed to unmarshal Integration as VictorOps: %s", err.Error())
		}
	}

	// check if the discriminator value is 'WEBHOOK'
	if jsonDict["type"] == "WEBHOOK" {
		// try to unmarshal JSON data into Webhook
		err = json.Unmarshal(data, &dst.Webhook)
		if err == nil {
			return nil // data stored in dst.Webhook, return on the first match
		} else {
			dst.Webhook = nil
			return fmt.Errorf("failed to unmarshal Integration as Webhook: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Webhook'
	if jsonDict["type"] == "Webhook" {
		// try to unmarshal JSON data into Webhook
		err = json.Unmarshal(data, &dst.Webhook)
		if err == nil {
			return nil // data stored in dst.Webhook, return on the first match
		} else {
			dst.Webhook = nil
			return fmt.Errorf("failed to unmarshal Integration as Webhook: %s", err.Error())
		}
	}

	return nil
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Integration) MarshalJSON() ([]byte, error) {
	if src.Datadog != nil {
		return json.Marshal(&src.Datadog)
	}

	if src.MicrosoftTeams != nil {
		return json.Marshal(&src.MicrosoftTeams)
	}

	if src.NewRelic != nil {
		return json.Marshal(&src.NewRelic)
	}

	if src.OpsGenie != nil {
		return json.Marshal(&src.OpsGenie)
	}

	if src.PagerDuty != nil {
		return json.Marshal(&src.PagerDuty)
	}

	if src.Prometheus != nil {
		return json.Marshal(&src.Prometheus)
	}

	if src.Slack != nil {
		return json.Marshal(&src.Slack)
	}

	if src.VictorOps != nil {
		return json.Marshal(&src.VictorOps)
	}

	if src.Webhook != nil {
		return json.Marshal(&src.Webhook)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *Integration) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.Datadog != nil {
		return obj.Datadog
	}

	if obj.MicrosoftTeams != nil {
		return obj.MicrosoftTeams
	}

	if obj.NewRelic != nil {
		return obj.NewRelic
	}

	if obj.OpsGenie != nil {
		return obj.OpsGenie
	}

	if obj.PagerDuty != nil {
		return obj.PagerDuty
	}

	if obj.Prometheus != nil {
		return obj.Prometheus
	}

	if obj.Slack != nil {
		return obj.Slack
	}

	if obj.VictorOps != nil {
		return obj.VictorOps
	}

	if obj.Webhook != nil {
		return obj.Webhook
	}

	// all schemas are nil
	return nil
}

type NullableIntegration struct {
	value *Integration
	isSet bool
}

func (v NullableIntegration) Get() *Integration {
	return v.value
}

func (v *NullableIntegration) Set(val *Integration) {
	v.value = val
	v.isSet = true
}

func (v NullableIntegration) IsSet() bool {
	return v.isSet
}

func (v *NullableIntegration) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableIntegration(val *Integration) *NullableIntegration {
	return &NullableIntegration{value: val, isSet: true}
}

func (v NullableIntegration) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableIntegration) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


